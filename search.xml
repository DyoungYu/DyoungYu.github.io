<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[通过dyld源码，详细分析应用加载]]></title>
    <url>%2F2019%2F01%2F14%2Fdyld%2F</url>
    <content type="text"><![CDATA[在我们初学iOS的时候，分析一个程序的执行流程都是从main函数开始的。但是在main函数之前其实也做了不少操作，值得我们分析一下。 我们知道一个类的load的方法是先于main函数执行的，通过对load方法设置一个断点，查看调用栈可知程序在加载过程中大致所执行的一些方法。 其中可见dyld（the dynamic link editor），它是苹果的动态链接器，是苹果操作系统一个重要组成部分，在系统内核做好程序准备工作之后，交由dyld负责余下的工作。通过分析dyld的源码,我们来分析dyld做了什么。 准备分析1、通过分析_dyld_start的汇编实现。发现调用了dyldbootstrap::start方法。 12345678# call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue) movl 8(%rbp),%esi # param2 = argc into %esi leaq 16(%rbp),%rdx # param3 = &amp;argv[0] into %rdx movq __dyld_start_static(%rip), %r8 leaq __dyld_start(%rip), %rcx subq %r8, %rcx # param4 = slide into %rcx leaq ___dso_handle(%rip),%r8 # param5 = dyldsMachHeader leaq -8(%rbp),%r9 2、在下载好的dyld源码中搜索dyldbootstrap,在这个命名空间中寻找start方法。在这个方法中，通过slideOfMainExecutable得到因ASLR产生的偏移。通过rebaseDyld重绑定。通过__guard_setup来栈溢出保护。 123uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader, uintptr_t* startGlue) 这个start的方法的返回值是调用了一个main函数,将start的一些值作为参数传到main。 1return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue); 3、dyld也可以看做一个程序的执行，它的main函数和我们日常开发应用的main函数类似，都可以看做程序的入口。接下来我们主要便是分析main函数的实现。 123_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue) 加载过程0x01 配置环境，设置环境变量等 设置上下文 1setContext(mainExecutableMH, argc, argv, envp, apple); 配置进程是否受限 1configureProcessRestrictions(mainExecutableMH); 检查环境变量 1checkEnvironmentVariables(envp); 根据Xcode设置的环境变量，来打印程序相应参数。 1234if ( sEnv.DYLD_PRINT_OPTS ) printOptions(argv);if ( sEnv.DYLD_PRINT_ENV ) printEnvironmentVariables(envp); 会打印程序相关的目录、用户级别、插入的动态库、动态库的路径等。 12345678910111213141516171819202122opt[0] = &quot;/var/containers/Bundle/Application/731D64D1-8B04-491B-A512-4010011413E6/dyld.app/dyld&quot;CA_DEBUG_TRANSACTIONS=0TMPDIR=/private/var/mobile/Containers/Data/Application/EF8F63AD-B59A-42E7-92EE-076BC9F664D0/tmp__CF_USER_TEXT_ENCODING=0x1F5:0:0SHELL=/bin/shSQLITE_ENABLE_THREAD_ASSERTIONS=1OS_ACTIVITY_DT_MODE=YESHOME=/private/var/mobile/Containers/Data/Application/EF8F63AD-B59A-42E7-92EE-076BC9F664D0DYLD_PRINT_TO_STDERR=YESCFFIXED_USER_HOME=/private/var/mobile/Containers/Data/Application/EF8F63AD-B59A-42E7-92EE-076BC9F664D0NSUnbufferedIO=YESPATH=/usr/bin:/bin:/usr/sbin:/sbinLOGNAME=mobileXPC_SERVICE_NAME=UIKitApplication:dyoung.dyld[0x1b53][62]DYLD_INSERT_LIBRARIES=/Developer/usr/lib/libBacktraceRecording.dylib:/Developer/usr/lib/libMainThreadChecker.dylib:/Developer/Library/PrivateFrameworks/DTDDISupport.framework/libViewDebuggerSupport.dylibCLASSIC=0DYLD_PRINT_OPTS=1DYLD_PRINT_ENV=1USER=mobileXPC_FLAGS=0x1CA_ASSERT_MAIN_THREAD_TRANSACTIONS=0DYLD_LIBRARY_PATH=/usr/lib/system/introspection 通过getHostInfo获取machO头部获取当前运行架构的信息。 1static void getHostInfo(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide) 0x02 加载共享缓存库。 判断共享缓存库是否被禁用。iOS cannot run without shared region，注释说明iOS平台下是不能被禁用的。 1checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide); 通过mapSharedCache()函数加载、进入函数内部其主要实现是loadDyldCache这个函数。其中作了如下三种判断 123456789101112131415161718 if ( options.forcePrivate ) &#123; // mmap cache into this process only //只加载到当前缓存。 return mapCachePrivate(options, results); &#125; else &#123; // fast path: when cache is already mapped into shared region //快速路径，如果已经加载的话就不处理了。 bool hasError = false; if ( reuseExistingCache(options, results) ) &#123; hasError = (results-&gt;errorMessage != nullptr); &#125; else &#123; // slow path: this is first process to load cache //第一次加载的话通过它来加载。 hasError = mapCacheSystemWide(options, results); &#125; return hasError;&#125; 0x03 实例化主程序(Mach0，程序的可执行文件) 实例化过程：instantiateFromLoadedImage 123456789101112static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)&#123; // try mach-o loader //isCompatibleMachO 是检查mach-o的subtype是否是当前cpu可以支持 if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123; ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext); addImage(image);//将image添加到imagelist。所以我们在Xcode使用image list命令查看的第一个便是我们的machO return (ImageLoaderMachO*)image; &#125; throw &quot;main executable not a known format&quot;;&#125; 0x04 加载插入库 通过loadInsertedDylib方法执行插入动态库的加载。在实现中调用load方法返回imageLoader对象， imageLoader是一个抽象基类，专门用于辅助加载特定可执行文件格式的类，对于程序中需要的依赖库、插入库，会创建一个对应的image对象，对这些image进行链接，调用各image的初始化方法等等，包括对runtime的初始化。 123456// load any inserted libraries if ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123;//遍历DYLD_INSERT_LIBRARIES的环境变量。 for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib); &#125; 0x05 链接主程序，并加载系统和第三方的动态库 在 main中通过link链接主程序。 12//main 函数中link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); 内部通过imageLoader的实例对象去调用link方法。 12//image调用linkimage-&gt;link(gLinkContext, forceLazysBound, false, neverUnload, loaderRPaths, path); 递归加载我们所需要的依赖的系统库和第三方库。 1this-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath); 对依赖库进行重定位。相当于加上ASLR滑块。 1this-&gt;recursiveRebase(context); 递归绑定符号表和弱绑定。 绑定就是将这个二进制调用的外部符号进行绑定的过程。比如我们objc代码中需要使用到NSObject, 即符号OBJC_CLASS$_NSObject，但是这个符号又不在我们的二进制中，在系统库 Foundation.framework中，因此就需要binding这个操作将对应关系绑定到一起。lazyBinding就是在加载动态库的时候不会立即binding, 当第一次调用这个方法的时候再实施binding。 做到的方法也很简单： 通过dyld_stub_binder 这个符号来做。lazy binding的方法第一次会调用到dyld_stub_binder, 然后dyld_stub_binder负责找到真实的方法，并且将地址bind到桩上，下一次就不用再bind了。 1this-&gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload); 1this-&gt;weakBind(context); 插入动态库。 12345678910111213if ( sInsertedDylibCount &gt; 0 ) &#123;//有的话就开始链接加载。 for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1];//1过滤到主程序。 link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); image-&gt;setNeverUnloadRecursive(); &#125; // only INSERTED libraries can interpose // register interposing info after all inserted libraries are bound so chaining works for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1]; image-&gt;registerInterposing(gLinkContext); &#125;&#125; 0x06 初始化函数，承前启后 一、dyld流程分析-&gt; 在main函数中我们进入initializeMainExecutable-&gt;runInitializers初始化主程序-&gt;processInitializers-&gt;recursiveInitialization循环初始化-&gt;关键函数 ：notifySingle。在这个方法中调用了objc的loadImages。通过command+shift+o全局搜索寻找实现。 1static void notifySingle(dyld_image_states state, const ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo) 发现一个函数指针的调用： 1(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader()); 通过在本文件搜索sNotifyObjCInit函数指针，我们找到了赋值的地方。 123void registerObjCNotifiers(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)&#123; sNotifyObjCInit = init;//赋值函数。 全局搜索registerObjCNotifiers调用的地方 123456void _dyld_objc_notify_register(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)&#123; dyld::registerObjCNotifiers(mapped, init, unmapped);&#125; 再次全局搜索_dyld_objc_notify_register便找不到这个方法调用。于是我们通过Xcode设置符号断点来分析。如图所示，我们则能推断出这个方法的调用是在runtime中。 二、runtime流程分析分析runtime源码。可知上面的函数是在其初始化的时候进行调用的。load_images赋值到dyld中的sNotifyObjCInit指针。 1234567891011121314void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);&#125; 在load_images中，完成call_load_methods的调用。 12345678910111213141516load_images(const char *path __unused, const struct mach_header *mh)&#123; // Return without taking locks if there are no +load methods here. if (!hasLoadMethods((const headerType *)mh)) return; recursive_mutex_locker_t lock(loadMethodLock); // Discover load methods &#123; mutex_locker_t lock2(runtimeLock); prepare_load_methods((const headerType *)mh); &#125; // Call +load methods (without runtimeLock - re-entrant) call_load_methods();&#125; 在call_load_methods中，通过doWhile循环来调用call_class_loads实现每个类的load方法。 1234567891011121314151617181920212223242526272829void call_load_methods(void)&#123; static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; // 1. Repeatedly call class +loads until there aren&apos;t any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125; 三、_ _ attribute_ _((constructor)) 是GCC的扩展语法（黑魔法），由它修饰过的函数，会在main函数之前调用。原理是在ELF的.ctors段增加一条函数引用，加载器在执行main函数前，检查.ctror section，并执行里面的函数。 继续dyld分析。在imageLoader.cpp文件中，notifySingle调用之后，接着调用了doInitialization方法。 其中doModInitFunctions会调用machO文件中_mod_init_func段的函数，也就是我们在文件中所定义的全局C++构造函数。 123456789101112bool ImageLoaderMachO::doInitialization(const LinkContext&amp; context)&#123; CRSetCrashLogMessage2(this-&gt;getPath()); // mach-o has -init and static initializers doImageInit(context); doModInitFunctions(context); CRSetCrashLogMessage2(NULL); return (fHasDashInit || fHasInitializers);&#125; 通过以上分析加载流程我们可得知函数的执行顺序为： 1load -&gt; attribute((constructor)) -&gt; main -&gt; initialize 0x07 寻找应用程序主函数入口最后return,dyld的main函数结束。 12// find entry point for main executableresult = (uintptr_t)sMainExecutable-&gt;getThreadPC(); 至此，程序进入了main函数，开启了我们熟知的一切。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>iOS正向</tag>
        <tag>iOS逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS应用脱壳(解密)的几种方式]]></title>
    <url>%2F2018%2F12%2F27%2F%E8%84%B1%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[我们日常开发提交给Appstore发布的App，都经过官方保护而加密，这样可以保证机器上跑的应用是苹果审核过的，也可以管理软件授权。经过App Store加密的应用，我们无法通过Hopper等反编译静态分析，也无法Class-Dump，在逆向分析过程中需要对加密的二进制文件进行解密才可以进行静态分析，这一过程就是大家熟知的砸壳（脱壳） #一、Clutch 由KJCracks开发的一款开源砸壳工具。 #####具体操作1、使用Clutch，下载最新的release版本,可得到一个名为Clutch-2.0.4的胖二进制文件。2、通过usb登录越狱设备。3、通过命令scp -P 12345 Clutch-2.0.4 root@localhost:/usr/bin将其拷贝到越狱设备的指定目录下。可通过mv Clutch-2.0.4 Clutch对其重命名。 4、查看Clutch的可执行权限。没有的话就chmod +x Clutch添加权限即可。5、进入到越狱设备的命令行操作界面。通过Clutch命令可查看相关命令帮助信息。1234567891011Dyoung5s:~ root# pwd/var/rootDyoung5s:~ root# ClutchUsage: Clutch [OPTIONS]-b --binary-dump &lt;value&gt; Only dump binary files from specified bundleID-d --dump &lt;value&gt; Dump specified bundleID into .ipa file-i --print-installed Print installed applications --clean Clean /var/tmp/clutch directory --version Display version and exit-? --help Display this help and exit-n --no-color Print with colors disabled 6、Clutch -i 显示可砸壳的应用列表。12345678910Dyoung5s:~ root# Clutch -iInstalled apps:1: 微博国际版 &lt;com.weibo.international&gt;2: 淘宝-双十二购物，移动生活社区 &lt;com.taobao.taobao4iphone&gt;3: 今日头条极速版 &lt;com.ss.iphone.article.lite&gt;4: QQ &lt;com.tencent.mqq&gt;5: DingTalk &lt;com.laiwang.DingTalk&gt;6: 酷狗音乐-就是歌多 &lt;com.kugou.kugou1002&gt;7: 抖音短视频 &lt;com.ss.iphone.ugc.Aweme&gt;8: 爱思助手 &lt;com.diary.mood&gt; 7、Clutch -d 4选择要砸壳的应用，并进行砸壳，成功后有如下提示。将其拷贝出来即可。我们也可以通过otool -l查看其cryptid字段以验证是否砸壳成功。 #二、dumpdecrypted 通过建立一个名为dumpdecrypted.dylib的动态库，插入目标应用实现脱壳。 1、下载dumpdecrypted，并通过make命令编译生成dylib库。2、通过命令scp -P 12345 dumpdecrypted.dylib root@localhost:~/将动态库拷贝越狱设备的指定目录。 3、通过ps -A查看当前进程，并通过如下命令将其动态库插入到指定进程中。即可生成对应进程应用的MachO文件。12//后面加上的进程路径。DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/A8CC18F5-9213-482E-B145-C36EFE9ACED0/DingTalk.app/DingTalk #三、frida-ios-dump #####安装1、下载pip1sudo easy_install pip 2、通过pip下载frida_tools123sudo -H pip install frida_tools//如果报下图中的错误则更换为另外一条命令。sudo pip install six --upgrade --ignore-installed six 3、直接clonefrida-ios-dump到本地目录，进入目录可发现dump.py脚本文件。 4、修改dump.py文件中的如下信息，确保与越狱设备信息匹配。 5、在越狱设备中添加https://build.frida.re源，并且安装Frida插件. #####dump应用将脱壳应用在设备上置于运行状态。进入脚本所在文件夹，通过./dump.py 微信便可成功脱壳应用。成功后会在脚本文件所在文件夹中生成ipa包。 以上dump时的操作可写成脚本,将frida-ios-dump文件夹放置sh脚本文件的同级目录中。编写脚本，并配置环境变量即可。12//脚本内容:dump.py的路径 $1 ######遇到的一些坑：1、No module named xxx。 通过pip install --user xxx下载即可。 2、from scp import xxx，同上执行pip install --user xxx即可。 3、生成ipa，存放到脚本文件所在文件夹时没有写的权限。可直接对文件夹执行sudo chmod -R 777 文件夹路径即可。 #四、lldb手动dump #####准备1、在手机中配置好debugserver。2、通过以下命令导出需要dump应用的可执行文件到当前路径。xxxx代表应用进程路径。1scp -P 12345 root@localhost:xxxx ./ 3、查看瘦身后的可执行文件的加密信息。并记录。 1234● otool -l Aweme_arm64 | grep cry cryptoff 16384 cryptsize 52527104 cryptid 1 分析：cryptoff：指加密文件的头所对应的偏移。这个数字之前代表着可执行文件的header。cryptsize: 加密的数据长度，我们需要把这段时间拷贝出来。 #####实操1、开启debugserver服务，依附到我们想要dump应用的进程中。1debugserver *:9393 -a Aweme 2、电脑进入lldb调试环境，连接到对应的debugserver端口。1process connect [connect://localhost:9393](connect://localhost:9393) 3、通过image list指令拿到可执行文件的头地址，加上之前的cryptoff得到需要拷贝数据的起始地址。 4、按字节读取内存中的可执行文件，并拷贝到电脑。（耗时动作）12345//--force:按字节读取。//0x00000001000c4000+16384：需要拷贝内容的起始地址。//52527104：需要拷贝内容的大小。//./decrypted.bin ： 在当前目录下生成一个名为decrypted.bin的二进制包。memory read --force --outfile ./decrypted.bin --binary --count 52527104 0x00000001000c4000+16384 5、将二进制文件包替换之前拷贝出来的可执行文件中的对应部分，得到一个新的可执行文件。1234//dd：用指定大小的文件写到另一个文件当中。//bs：一个一个字节写入//conv：指定转换文件的方式。dd seek=16384 bs=1 conv=notrunc if=./decrypted.bin of=./Aweme_arm64 6、通过otool -l查看新的可执行文件，得知cryptid仍为1,这里是因为我们并没有对header文件作修改，所以字段的值仍保持之前加密的键值。但是可执行文件的内容却被我们解密了的。可以通过class-dump验证。 7、通过Mach0View 修改cryptid的值为0。如果不修改class-dump会不成功。因为这个工具首先会拿到header获取cryptid的值，如果是已加密的话就会放弃后面的dump工作了。 8、通过class-dump -H Aweme_arm64 -o ./AwemeHeaders能导出应用的头文件，便可证明lldb手动脱壳成功。 #补充 #####frida_tools的一些使用1、配置端口映射。通过frida-ps列出当前应用进程。通过usb连接好手机后，通过frida-ps -U列出usb设备的应用进程。2、通过frida -U 微信附加进程到微信。3、执行ObjC可拿到附加进程应用的所有Object-C对象。 #####插入自定义动态库到指定应用 通过这样的操作，进程没有被污染，在以后的每次执行时候不会执行我们所插入的动态库的方法。这里只相当于一次性插入。上文的dumpdecrypted便是用到了这样的原理。 1、使用Xcode生成framework文件。通过以下命令拷贝到越狱设备中。1scp -r -P 12345 DyInsert.framework/ root@localhost:~/ 2、通过以下命令将动态库插入到指定进程即可。1DYLD_INSERT_LIBRARIES=DyInsert.framework/DyInsert /var/mobile/Containers/Bundle/Application/4560ADA4-9AE4-4E9D-BE84-ABF666B12A7A/WeChat.app/WeChat]]></content>
      <tags>
        <tag>iOS逆向</tag>
      </tags>
  </entry>
</search>
