<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS多线程 - GCD基础实践]]></title>
    <url>%2F2019%2F05%2F07%2FiOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD%E5%9F%BA%E7%A1%80%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。下面介绍GCD的基础使用. 0x01 基本组合 两种队列+两种任务执行方式异步(async)不等待，和非主队列的组合会默认开启线程。 1、同步+并发 = 串行1234567891011121314151617181920212223242526272829303132//MARK: =&gt; 同步+并发=串行- (void)gcdTest1&#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;syncConcurrent---begin&quot;); //创建同步队列。 dispatch_queue_t queue = dispatch_queue_create(&quot;testQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_sync(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@&quot;syncConcurrent---end&quot;);&#125; 打印结果: 123456789currentThread---&lt;NSThread: 0x600003cca900&gt;&#123;number = 1, name = main&#125;syncConcurrent---begin1---&lt;NSThread: 0x600003cca900&gt;&#123;number = 1, name = main&#125;1---&lt;NSThread: 0x600003cca900&gt;&#123;number = 1, name = main&#125;2---&lt;NSThread: 0x600003cca900&gt;&#123;number = 1, name = main&#125;2---&lt;NSThread: 0x600003cca900&gt;&#123;number = 1, name = main&#125;3---&lt;NSThread: 0x600003cca900&gt;&#123;number = 1, name = main&#125;3---&lt;NSThread: 0x600003cca900&gt;&#123;number = 1, name = main&#125;syncConcurrent---end 2、异步+并发=并行12345678910111213141516171819202122232425262728293031323334//MARK: =&gt; 异步+并发=并行- (void)gcdTest2&#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;asyncConcurrent---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@&quot;asyncConcurrent---end&quot;);&#125; 打印结果: 因为追加的三个任务为异步执行，所以可先执行end。 123456789currentThread---&lt;NSThread: 0x600003959300&gt;&#123;number = 1, name = main&#125;asyncConcurrent---beginasyncConcurrent---end2---&lt;NSThread: 0x60000393e3c0&gt;&#123;number = 4, name = (null)&#125;1---&lt;NSThread: 0x600003924580&gt;&#123;number = 3, name = (null)&#125;3---&lt;NSThread: 0x600003916780&gt;&#123;number = 5, name = (null)&#125;1---&lt;NSThread: 0x600003924580&gt;&#123;number = 3, name = (null)&#125;2---&lt;NSThread: 0x60000393e3c0&gt;&#123;number = 4, name = (null)&#125;3---&lt;NSThread: 0x600003916780&gt;&#123;number = 5, name = (null)&#125; 3、同步+串行=串行12345678910111213141516171819202122232425262728NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;syncSerial---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@&quot;syncSerial---end&quot;); 打印结果: 123456789currentThread---&lt;NSThread: 0x600002330000&gt;&#123;number = 1, name = main&#125;syncSerial---begin1---&lt;NSThread: 0x600002330000&gt;&#123;number = 1, name = main&#125;1---&lt;NSThread: 0x600002330000&gt;&#123;number = 1, name = main&#125;2---&lt;NSThread: 0x600002330000&gt;&#123;number = 1, name = main&#125;2---&lt;NSThread: 0x600002330000&gt;&#123;number = 1, name = main&#125;3---&lt;NSThread: 0x600002330000&gt;&#123;number = 1, name = main&#125;3---&lt;NSThread: 0x600002330000&gt;&#123;number = 1, name = main&#125;syncSerial---end 4、异步+串行=串行1234567891011121314151617181920212223242526272829303132 NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;asyncSerial---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123;// dispatch_async(dispatch_get_main_queue(), ^&#123;// sleep(10);// NSLog(@&quot;回到了主线程&quot;);// &#125;); // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@&quot;asyncSerial---end&quot;); 打印结果123456789currentThread---&lt;NSThread: 0x600001538b00&gt;&#123;number = 1, name = main&#125;asyncSerial---beginasyncSerial---end1---&lt;NSThread: 0x600001540240&gt;&#123;number = 3, name = (null)&#125;1---&lt;NSThread: 0x600001540240&gt;&#123;number = 3, name = (null)&#125;2---&lt;NSThread: 0x600001540240&gt;&#123;number = 3, name = (null)&#125;2---&lt;NSThread: 0x600001540240&gt;&#123;number = 3, name = (null)&#125;3---&lt;NSThread: 0x600001540240&gt;&#123;number = 3, name = (null)&#125;3---&lt;NSThread: 0x600001540240&gt;&#123;number = 3, name = (null)&#125; 5、主队列中同步执行任务。 因为默认下面代码是在主队列中执行的。简称下面代码为任务A。当追加任务1后，因为是同步执行，任务1需要等到任务A执行完毕后再执行任务1。而任务A的执行依赖于任务1.所以会造成死锁。 123456789101112131415161718192021222324252627282930NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;syncMain---begin&quot;); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_sync(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@&quot;syncMain---end&quot;); 6、主队列+异步123456789101112131415161718192021222324252627282930NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;asyncMain---begin&quot;); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_async(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@&quot;asyncMain---end&quot;); 打印结果 效果同：串行队列+异步执行 123456789currentThread---&lt;NSThread: 0x600002b65240&gt;&#123;number = 1, name = main&#125;asyncMain---beginasyncMain---end1---&lt;NSThread: 0x600002b65240&gt;&#123;number = 1, name = main&#125;1---&lt;NSThread: 0x600002b65240&gt;&#123;number = 1, name = main&#125;2---&lt;NSThread: 0x600002b65240&gt;&#123;number = 1, name = main&#125;2---&lt;NSThread: 0x600002b65240&gt;&#123;number = 1, name = main&#125;3---&lt;NSThread: 0x600002b65240&gt;&#123;number = 1, name = main&#125;3---&lt;NSThread: 0x600002b65240&gt;&#123;number = 1, name = main&#125; 7、线程通信12345678910111213141516171819// 获取全局并发队列dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 获取主队列dispatch_queue_t mainQueue = dispatch_get_main_queue();dispatch_async(queue, ^&#123; // 回到主线程 dispatch_async(mainQueue, ^&#123; // 追加在主线程中执行的任务 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); // 异步追加任务 for (int i = 0; i &lt; 10; ++i) &#123; [NSThread sleepForTimeInterval:1]; // 模拟耗时操作 NSLog(@&quot;1-%d--%@&quot;,i,[NSThread currentThread]); // 打印当前线程 &#125;&#125;); 打印结果 在全局队列中，异步添加主队列任务。主队列任务不会阻塞全局队列的任务，但是不确定主队列任务在何时执行完。 12345678910111-0--&lt;NSThread: 0x60000201bfc0&gt;&#123;number = 3, name = (null)&#125;1-1--&lt;NSThread: 0x60000201bfc0&gt;&#123;number = 3, name = (null)&#125;2---&lt;NSThread: 0x600002072940&gt;&#123;number = 1, name = main&#125;1-2--&lt;NSThread: 0x60000201bfc0&gt;&#123;number = 3, name = (null)&#125;1-3--&lt;NSThread: 0x60000201bfc0&gt;&#123;number = 3, name = (null)&#125;1-4--&lt;NSThread: 0x60000201bfc0&gt;&#123;number = 3, name = (null)&#125;1-5--&lt;NSThread: 0x60000201bfc0&gt;&#123;number = 3, name = (null)&#125;1-6--&lt;NSThread: 0x60000201bfc0&gt;&#123;number = 3, name = (null)&#125;1-7--&lt;NSThread: 0x60000201bfc0&gt;&#123;number = 3, name = (null)&#125;1-8--&lt;NSThread: 0x60000201bfc0&gt;&#123;number = 3, name = (null)&#125;1-9--&lt;NSThread: 0x60000201bfc0&gt;&#123;number = 3, name = (null)&#125; 0x02 栅栏函数 dispatch_barrier_async函数的作用与barrier的意思相同,在进程管理中起到一个栅栏的作用,它等待所有位于barrier函数之前的操作执行完毕后执行。值得注意的是：1、在barrier函数执行之后,barrier函数之后的操作才会得到执行。2、该函数需要同dispatch_queue_create函数生成的concurrent Dispatch Queue队列一起使用。全局队列在此使用是无效的。 12345678910111213141516171819202122232425262728293031323334353637383940414243 //创建并发队列。 dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT); //栅栏函数只能在自己新建的队列中才有效。全局队列并不生效。// dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0); dispatch_async(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_barrier_async(queue, ^&#123; // 追加任务 barrier for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;barrier---%@&quot;,[NSThread currentThread]);// 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务4 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;4---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); 打印结果 123456789102---&lt;NSThread: 0x6000030f5440&gt;&#123;number = 4, name = (null)&#125;1---&lt;NSThread: 0x6000030f5400&gt;&#123;number = 3, name = (null)&#125;1---&lt;NSThread: 0x6000030f5400&gt;&#123;number = 3, name = (null)&#125;2---&lt;NSThread: 0x6000030f5440&gt;&#123;number = 4, name = (null)&#125;barrier---&lt;NSThread: 0x6000030f5440&gt;&#123;number = 4, name = (null)&#125;barrier---&lt;NSThread: 0x6000030f5440&gt;&#123;number = 4, name = (null)&#125;3---&lt;NSThread: 0x6000030f5440&gt;&#123;number = 4, name = (null)&#125;4---&lt;NSThread: 0x6000030f5400&gt;&#123;number = 3, name = (null)&#125;4---&lt;NSThread: 0x6000030f5400&gt;&#123;number = 3, name = (null)&#125;3---&lt;NSThread: 0x6000030f5440&gt;&#123;number = 4, name = (null)&#125; 0x03 队列组 在使用GCD进行任务操作时，有时会希望若干个任务执行之间有先后执行的依赖关系，例如，当A、B两个异步任务完成后，再去完成C任务，这时就可以使用队列组dispatch group来完成。 1、组合一 dispatch_group_t dispatch_group_async dispatch_group_notify 1234567891011121314151617181920212223242526272829NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;group---begin&quot;); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; NSLog(@&quot;group---end&quot;); &#125;); 打印结果 notify中的任务会在线程组的其它任务执行完成后执行。 123456789currentThread---&lt;NSThread: 0x600000f62940&gt;&#123;number = 1, name = main&#125;group---begin2---&lt;NSThread: 0x600000f1c480&gt;&#123;number = 3, name = (null)&#125;1---&lt;NSThread: 0x600000f7fdc0&gt;&#123;number = 4, name = (null)&#125;2---&lt;NSThread: 0x600000f1c480&gt;&#123;number = 3, name = (null)&#125;1---&lt;NSThread: 0x600000f7fdc0&gt;&#123;number = 4, name = (null)&#125;3---&lt;NSThread: 0x600000f62940&gt;&#123;number = 1, name = main&#125;3---&lt;NSThread: 0x600000f62940&gt;&#123;number = 1, name = main&#125;group---end 2、组合二 暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。 1、dispatch_group_t 2、dispatch_group_async 3、dispatch_group_wait 阻塞。 1234567891011121314151617181920212223242526NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;group---begin&quot;); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 追加任务1 for (int i = 0; i &lt; 5; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_queue_t queue = dispatch_queue_create(&quot;dyoung&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_group_async(group, queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 5; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); // 等待上面group中的任务全部完成后，会往下继续执行（会阻塞当前线程） dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@&quot;group---end&quot;); 打印结果 12345678910111213currentThread---&lt;NSThread: 0x600003d47f00&gt;&#123;number = 1, name = main&#125;group---begin2---&lt;NSThread: 0x600003d10bc0&gt;&#123;number = 4, name = (null)&#125;1---&lt;NSThread: 0x600003d35300&gt;&#123;number = 3, name = (null)&#125;2---&lt;NSThread: 0x600003d10bc0&gt;&#123;number = 4, name = (null)&#125;1---&lt;NSThread: 0x600003d35300&gt;&#123;number = 3, name = (null)&#125;1---&lt;NSThread: 0x600003d35300&gt;&#123;number = 3, name = (null)&#125;2---&lt;NSThread: 0x600003d10bc0&gt;&#123;number = 4, name = (null)&#125;2---&lt;NSThread: 0x600003d10bc0&gt;&#123;number = 4, name = (null)&#125;1---&lt;NSThread: 0x600003d35300&gt;&#123;number = 3, name = (null)&#125;2---&lt;NSThread: 0x600003d10bc0&gt;&#123;number = 4, name = (null)&#125;1---&lt;NSThread: 0x600003d35300&gt;&#123;number = 3, name = (null)&#125;group---end 3、组合三 dispatch_group_enter、 dispatch_group_leave dispatch_group_notify 12345678910111213141516171819202122232425262728293031323334NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程NSLog(@&quot;group---begin&quot;);dispatch_group_t group = dispatch_group_create();dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_enter(group);dispatch_async(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; dispatch_group_leave(group);&#125;);dispatch_group_enter(group);dispatch_async(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; dispatch_group_leave(group);&#125;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 等前面的异步操作都执行完毕后，回到主线程. for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; NSLog(@&quot;group---end&quot;);&#125;); 打印结果 123456789currentThread---&lt;NSThread: 0x600003b2c580&gt;&#123;number = 1, name = main&#125;group---begin2---&lt;NSThread: 0x600003b42b00&gt;&#123;number = 4, name = (null)&#125;1---&lt;NSThread: 0x600003b59a00&gt;&#123;number = 3, name = (null)&#125;2---&lt;NSThread: 0x600003b42b00&gt;&#123;number = 4, name = (null)&#125;1---&lt;NSThread: 0x600003b59a00&gt;&#123;number = 3, name = (null)&#125;3---&lt;NSThread: 0x600003b2c580&gt;&#123;number = 1, name = main&#125;3---&lt;NSThread: 0x600003b2c580&gt;&#123;number = 1, name = main&#125;group---end 0x04 信号量 dispatch_semaphore_create：创建一个Semaphore并初始化信号的总量 dispatch_semaphore_signal：发送一个信号，让信号总量加1 dispatch_semaphore_wait：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。 保持线程同步，将异步执行任务转换为同步执行任务 保证线程安全，为线程加锁 信号量在等待的时候，耗能较少。 1234567891011121314dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //初始化信号量为1.所以wait可以写在任务前面。 dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); for (int i = 0; i &lt; 5; i++) &#123; //必须放block外面。 dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); dispatch_async(globalQueue, ^&#123; //先判断，再减 1。 [NSThread sleepForTimeInterval:0.5]; NSLog(@&quot;i=%d---thread==%@\n&quot;,i,[NSThread currentThread]); dispatch_semaphore_signal(semaphore); &#125;); &#125; 同步打印： 12345i=0---thread==&lt;NSThread: 0x600000e4a080&gt;&#123;number = 3, name = (null)&#125;i=1---thread==&lt;NSThread: 0x600000e4a080&gt;&#123;number = 3, name = (null)&#125;i=2---thread==&lt;NSThread: 0x600000e4a080&gt;&#123;number = 3, name = (null)&#125;i=3---thread==&lt;NSThread: 0x600000e4a080&gt;&#123;number = 3, name = (null)&#125;i=4---thread==&lt;NSThread: 0x600000e4a080&gt;&#123;number = 3, name = (null)&#125; 0x05 通过信号量保证线程安全123456789101112131415161718192021222324- (void)gcdTest16&#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 self.ticketSurplusCount = 50; //开两个同步队列。 // queue1 代表北京火车票售卖窗口 dispatch_queue_t queue1 = dispatch_queue_create(&quot;net.bujige.testQueue1&quot;, DISPATCH_QUEUE_SERIAL); // queue2 代表上海火车票售卖窗口 dispatch_queue_t queue2 = dispatch_queue_create(&quot;net.bujige.testQueue2&quot;, DISPATCH_QUEUE_SERIAL); //创建信号量。 _semaphoreLock = dispatch_semaphore_create(1); // __weak typeof(self) weakSelf = self; dispatch_async(queue1, ^&#123; NSLog(@&quot;1&quot;); [self saleTicketNotSafe];//weakself没值的问题。 &#125;); dispatch_async(queue2, ^&#123; NSLog(@&quot;2&quot;); [self saleTicketNotSafe]; &#125;);&#125; 12345678910111213141516- (void)saleTicketNotSafe &#123; NSLog(@&quot;11&quot;); while (1) &#123; dispatch_semaphore_wait(_semaphoreLock, DISPATCH_TIME_FOREVER); if (self.ticketSurplusCount &gt; 0) &#123; //如果还有票，继续售卖 self.ticketSurplusCount--; NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%ld 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]); [NSThread sleepForTimeInterval:0.5]; &#125; else &#123; //如果已卖完，关闭售票窗口 NSLog(@&quot;所有火车票均已售完&quot;); break; &#125; // 相当于解锁 dispatch_semaphore_signal(_semaphoreLock); &#125;&#125; 0x06 快速迭代，并发遍历123456789dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); NSLog(@&quot;apply---begin&quot;); //dispatch_apply 可以 在多个线程中同时（异步）遍历多个数字。 //无论是在串行队列，还是异步队列中，dispatch_apply 都会等待全部任务执行完毕 dispatch_apply(100, queue, ^(size_t index) &#123; [NSThread sleepForTimeInterval:0.5]; NSLog(@&quot;%zd---%@&quot;,index, [NSThread currentThread]); &#125;); NSLog(@&quot;apply---end&quot;);//这个肯定在最后执行。 打印结果 无序，但是保证每个都被遍历到。 123456789apply---begin3---&lt;NSThread: 0x60000098a9c0&gt;&#123;number = 5, name = (null)&#125;2---&lt;NSThread: 0x6000009a5c80&gt;&#123;number = 3, name = (null)&#125;0---&lt;NSThread: 0x6000009c0dc0&gt;&#123;number = 1, name = main&#125;1---&lt;NSThread: 0x600000989bc0&gt;&#123;number = 4, name = (null)&#125;···apply---end 0x07 其它用法延迟执行1234dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 2.0秒后异步追加任务代码到主队列，并开始执行 NSLog(@&quot;after---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); 单例用法1234static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@&quot;🍺🍺🍺🍺🍺 onceToken&quot;); &#125;); 0x08 备注更多GCD介绍参考iOS多线程:GCD详尽总结本文Demo:DyGCDTest.m]]></content>
      <categories>
        <category>iOS正向</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法 - 二叉树]]></title>
    <url>%2F2019%2F04%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[在计算机科学中，二叉树(Binary Tree)是包含n个节点的有限集合，该集合或者为空集（此时，二叉树称为空树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。 前文本文主要讲述了对二叉排序树的创建及其它操作，二叉排序树具有以下几个特点：12341、若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；2、若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；3、任意节点的左、右子树也分别为二叉查找树；4、没有键值相等的节点。 接下来我们通过用OC代码实现的方式完成对二叉排序树的一些基础操作，其中主要就是考察我们的递归思想。首先我们以二叉树的节点为一个类创建一个类，这个类拥有两个属性，分别是左节点和右节点。如下所示： 1234@interface DyBinaryTreeNode : NSObject@property (nonatomic, strong) DyBinaryTreeNode *leftNode;@property (nonatomic, strong) DyBinaryTreeNode *rightNode; 接着，我们便可以依次定义并实现其操作方法了。 0x01 创建二叉排序树1、创建二叉树123456789101112/ * @param values 数组 * @return 二叉树根节点 */+ (DyBinaryTreeNode *)createTreeWithValues:(NSArray *)values &#123; DyBinaryTreeNode *root = nil; for (NSInteger i=0; i&lt;values.count; i++) &#123; NSInteger value = [(NSNumber *)[values objectAtIndex:i] integerValue]; root = [DyBinaryTreeNode addTreeNode:root value:value]; &#125; return root;&#125; 我们通过以下方法调用：123NSArray *arr = [NSArray arrayWithObjects:@(7),@(6),@(3),@(2),@(1),@(9),@(10),@(12),@(14),@(4),@(15),nil];DyBinaryTreeNode *tree = [DyBinaryTreeNode new];tree = [DyBinaryTreeNode createTreeWithValues:arr]; 会生成如下图所示的二叉排序树： 2、获取某个位置的节点（层序） 大致思路1、将根节点加到队列中，当队列有元素时循环。2、循环一次将队列的第一个元素出队列，index-13、当index=0时返回此时的根节点。4、遍历队列第一个元素(根节点)的左节点和右节点，加到队列中。 1234567891011121314151617181920212223242526272829303132 /* @param index 按层次遍历树时的位置(从0开始算) * @param rootNode 树根节点 * @return 节点 */+ (DyBinaryTreeNode *)treeNodeAtIndex:(NSInteger)index inTree:(DyBinaryTreeNode *)rootNode &#123; //按层次遍历 if (!rootNode || index &lt; 0) &#123; return nil; &#125; //数组当成队列 NSMutableArray *queueArray = [NSMutableArray array]; //压入根节点 [queueArray addObject:rootNode]; while (queueArray.count &gt; 0) &#123; DyBinaryTreeNode *node = [queueArray firstObject]; if (index == 0) &#123;//返回根节点。 return node; &#125; //弹出最前面的节点，仿照队列先进先出原则 [queueArray removeObjectAtIndex:0]; //移除节点，index减少 index--; if (node.leftNode) &#123; [queueArray addObject:node.leftNode]; //压入左节点 &#125; if (node.rightNode) &#123; [queueArray addObject:node.rightNode]; //压入右节点 &#125; &#125; //层次遍历完，仍然没有找到位置，返回nil return nil;&#125; 调用当index==8时，打印的值为1。 12DyBinaryTreeNode *tree1 = [DyBinaryTreeNode treeNodeAtIndex:8 inTree:tree];NSLog(@&quot;节点值为==%ld\n&quot;,tree1.value); 0x02 二叉树遍历分为先序遍历、中序遍历、后序遍历、层序遍历。先、中、后主要是指遍历根的顺序，如果先遍历根便是先序，其它类似。左节点和右节点的遍历顺序固定(先左后右)。层序遍历：从上至下，从左至右依次遍历。可参考wiki的树的遍历 1、先序遍历 先访问根，再遍历左子树，再遍历右子树。典型的递归思想。通过block，依次将遍历到的node值回调回去。 1234567891011121314/ * 根-左-右@param rootNode 根节点 * @param handler 访问节点处理函数 */+ (void)preOrderTraverseTree:(DyBinaryTreeNode *)rootNode handler:(void(^)(DyBinaryTreeNode *treeNode))handler &#123; if (rootNode) &#123; if (handler) &#123; handler(rootNode);//根 &#125; [DyBinaryTreeNode preOrderTraverseTree:rootNode.leftNode handler:handler];//左 [DyBinaryTreeNode preOrderTraverseTree:rootNode.rightNode handler:handler];//右 &#125;&#125; 2、中序遍历 先遍历左子树，再访问根，再遍历右子树 1234567891011121314/** * 左 根 右 * @param rootNode 根节点 * @param handler 访问节点处理函数 */+ (void)inOrderTraverseTree:(DyBinaryTreeNode *)rootNode handler:(void(^) (DyBinaryTreeNode *treeNode))handler &#123; if (rootNode) &#123; [DyBinaryTreeNode inOrderTraverseTree:rootNode.leftNode handler:handler];//左 if (handler) &#123; handler(rootNode);//中 &#125; [DyBinaryTreeNode inOrderTraverseTree:rootNode.rightNode handler:handler];//右 &#125;&#125; 3、后序遍历 先遍历左子树，再遍历右子树，再访问根 12345678910111213/** * @param rootNode 根节点 * @param handler 访问节点处理函数 */+ (void)postOrderTraverseTree:(DyBinaryTreeNode *)rootNode handler:(void(^)(DyBinaryTreeNode *treeNode))handler &#123; if (rootNode) &#123; [DyBinaryTreeNode postOrderTraverseTree:rootNode.leftNode handler:handler]; [DyBinaryTreeNode postOrderTraverseTree:rootNode.rightNode handler:handler]; if (handler) &#123; handler(rootNode); &#125; &#125;&#125; 以上三种遍历方式依次打印为： 123先序遍历结果：7,6,3,2,1,4,9,10,12,14,15中序遍历结果：1,2,3,4,6,7,9,10,12,14,15后序遍历结果：1,2,4,3,6,15,14,12,10,9,7 3、层序遍历 同上根据index获取节点的值的思想一样。通过数组模拟队列，进行遍历操作。 1234567891011121314151617181920+ (void)levelTraverseTree:(DyBinaryTreeNode *)rootNode handler:(void(^)(DyBinaryTreeNode *treeNode))handler &#123; if (!rootNode) &#123; return; &#125; NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列 [queueArray addObject:rootNode]; //压入根节点 while (queueArray.count &gt; 0) &#123; DyBinaryTreeNode *node = [queueArray firstObject]; if (handler) &#123; handler(node); &#125; [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先 出原则 if (node.leftNode) &#123; [queueArray addObject:node.leftNode]; //压入左节点 &#125; if (node.rightNode) &#123; [queueArray addObject:node.rightNode]; //压入右节点 &#125; &#125;&#125; 0x03 获取二叉树的属性1、获取二叉树的深度 二叉树的深度从根节点到叶子节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度包含的节点数为树的深度。可以理解为二叉树有多少层。 递归思想：二叉树的深度 = MAX(左子树深度，右子树深度)+11:根节点。 1234567891011121314151617181920/* * @param rootNode 二叉树根节点 * * @return 二叉树的深度 */+ (NSInteger)depthOfTree:(DyBinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return 0; &#125; if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123; return 1; &#125; //左子树深度 NSInteger leftDepth = [DyBinaryTreeNode depthOfTree:rootNode.leftNode]; //右子树深度 NSInteger rightDepth = [DyBinaryTreeNode depthOfTree:rootNode.rightNode]; return MAX(leftDepth, rightDepth) + 1;&#125; 2、获取二叉树的宽度 队列的最大长度，结点数最多的层的结点数。思想：同层序遍历，保存队列中最多元素时的元素个数。 1234567891011121314151617181920212223242526272829303132333435/* * @param rootNode 二叉树根节点 * * @return 二叉树宽度 */+ (NSInteger)widthOfTree:(DyBinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return 0; &#125; NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列 [queueArray addObject:rootNode]; //压入根节点 NSInteger maxWidth = 1; //最大的宽度，初始化为1（因为已经有根节点） NSInteger curWidth = 0; //当前层的宽度 while (queueArray.count &gt; 0) &#123; curWidth = queueArray.count; //依次弹出当前层的节点 for (NSInteger i=0; i&lt;curWidth; i++) &#123; DyBinaryTreeNode *node = [queueArray firstObject]; [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则 //压入子节点 if (node.leftNode) &#123; [queueArray addObject:node.leftNode]; &#125; if (node.rightNode) &#123; [queueArray addObject:node.rightNode]; &#125; &#125; //宽度 = 当前层节点数 maxWidth = MAX(maxWidth, queueArray.count); &#125; return maxWidth;&#125; 3、获取二叉树的节点数递归思想：节点数=左子树节点数+右子树节点数+1（根节点） 1234567+ (NSInteger)numberOfNodesInTree:(DyBinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return 0; &#125; //节点数=左子树节点数+右子树节点数+1（根节点） return [DyBinaryTreeNode numberOfNodesInTree:rootNode.leftNode] + [DyBinaryTreeNode numberOfNodesInTree:rootNode.rightNode] + 1;&#125; 4、获取二叉树某一层的节点数递归思想：level层节点数 = 左子树level-1层节点数+右子树level-1层节点数 12345678910+ (NSInteger)numberOfNodesOnLevel:(NSInteger)level inTree:(DyBinaryTreeNode *)rootNode &#123; if (!rootNode || level &lt; 1) &#123; //根节点不存在或者level&lt;0 return 0; &#125; if (level == 1) &#123; //level=1，返回1（根节点） return 1; &#125; //递归：level层节点数 = 左子树level-1层节点数+右子树level-1层节点数 return [DyBinaryTreeNode numberOfNodesOnLevel:level-1 inTree:rootNode.leftNode] + [DyBinaryTreeNode numberOfNodesOnLevel:level-1 inTree:rootNode.rightNode];&#125; 5、获取叶子节点数 叶子节点：左子树和右子树都是空的节点。递归思想：叶子数 = 左子树叶子数 + 右子树叶子数 1234567891011+ (NSInteger)numberOfLeafsInTree:(DyBinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return 0; &#125; //左子树和右子树都是空，说明是叶子节点 if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123; return 1; &#125; //递归：叶子数 = 左子树叶子数 + 右子树叶子数 return [DyBinaryTreeNode numberOfLeafsInTree:rootNode.leftNode] + [DyBinaryTreeNode numberOfLeafsInTree:rootNode.rightNode];&#125; 6、获取二叉树的最大直径 二叉树看成一个图，父子节点之间的连线看成是双向的，定义“距离”为两个节点之间的边数。 递归思想：分为三种情况1、最远距离经过根节点：距离 = 左子树深度 + 右子树深度2、最远距离在根节点左子树上，即计算左子树最远距离3、最远距离在根节点右子树上，即计算右子树最远距离 1234567891011+ (NSInteger)maxDistanceOfTree:(DyBinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return 0; &#125; //方案一：（递归次数较多，效率较低） NSInteger distance = [DyBinaryTreeNode depthOfTree:rootNode.leftNode] + [DyBinaryTreeNode depthOfTree:rootNode.rightNode]; NSInteger disLeft = [DyBinaryTreeNode maxDistanceOfTree:rootNode.leftNode]; NSInteger disRight = [DyBinaryTreeNode maxDistanceOfTree:rootNode.rightNode]; return MAX(MAX(disLeft, disRight), distance);&#125; 0x04 翻转二叉树 又叫：二叉树的镜像。交换节点的左节点和右节点。 1、递归翻转递归思想：先交换当前节点的左右节点，再递归调用去翻转以左右节点为根节点的二叉树。 123456789101112131415161718+ (DyBinaryTreeNode *)invertBinaryTree:(DyBinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return nil; &#125; if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123; return rootNode; &#125; //交换当前节点的左右节点。 DyBinaryTreeNode *tempNode = rootNode.leftNode; rootNode.leftNode = rootNode.rightNode; rootNode.rightNode = tempNode; //递归交换左右子节点 [DyBinaryTreeNode invertBinaryTree:rootNode.leftNode]; [DyBinaryTreeNode invertBinaryTree:rootNode.rightNode]; return rootNode;&#125; 2、非递归翻转思想：类似于层序遍历，将即将入队列的节点交换其左右节点。 123456789101112131415161718192021222324252627/** * 非递归方式翻转 */+ (DyBinaryTreeNode *)invertBinaryTreeNot:(DyBinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return nil; &#125; if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123; return rootNode; &#125; NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列 [queueArray addObject:rootNode]; //压入根节点 while (queueArray.count &gt; 0) &#123; DyBinaryTreeNode *node = [queueArray firstObject]; [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则 DyBinaryTreeNode *pLeft = node.leftNode; node.leftNode = node.rightNode; node.rightNode = pLeft; if (node.leftNode) &#123; [queueArray addObject:node.leftNode]; &#125; if (node.rightNode) &#123; [queueArray addObject:node.rightNode]; &#125; &#125; return rootNode;&#125; 备注关于二叉树的基本算法先介绍到此处，后续会补充更多关于二叉树操作的一些算法。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Runtime源码，分析OC消息发送及处理]]></title>
    <url>%2F2019%2F03%2F04%2Fruntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%2F</url>
    <content type="text"><![CDATA[前言日常开发中我们得知，当我们通过对象调用一个方法时，本质是通过objc_msgSend给对象发送消息。这点我们可以通过clang编译后的代码得知。 1MyPerson *p = [MyPerson new]; 通过xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc OC源文件 -o 输出的CPP文件编译得： 1MyPerson *p = ((MyPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;MyPerson&quot;), sel_registerName(&quot;new&quot;)); 可知接收消息的对象是：(id)objc_getClass(&quot;MyPerson&quot;)。接收的消息编号：sel_registerName(&quot;new&quot;) == @selector(new)。通过分析objc4-750源码，以objc_msgSend为入口，接下来我们开始分析整个消息发送及处理流程。 整个流程分为快速和慢速两种方式。快速：通过汇编，在缓存(cache)的imp哈希表中寻找。这样的好处是C、C++等语言不能通过写一个函数，来直接保留未知的参数，跳转到任意的指针。而汇编通过调用寄存器，可很好的实现这一点。慢速： 通过C、C++在方法列表中寻找。找到了会往chche中存。以上方法找不到，就会通过特殊的动态处理。 0x01 汇编缓存查找在objc4-750源码中搜索_objc_msgSend,点击查看在arm64架构中的ENTRY _objc_msgSend。代码和注释如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556ENTRY _objc_msgSend UNWIND _objc_msgSend, NoFrame//tagged pointer：特殊的数据类型，更为轻量。 cmp p0, #0 // nil check and tagged pointer check#if SUPPORT_TAGGED_POINTERS b.le LNilOrTagged // (MSB tagged pointer looks negative)#else b.eq LReturnZero#endif ldr p13, [x0] // p13 = isa GetClassFromIsa_p16 p13 // p16 = class LGetIsaDone://isa处理完毕。//这里可以作为后面传参的一个参考。//！！主要函数！！//在缓存列表中找imp//这里CacheLookup有三种方式：NORMAL|GETIMP|LOOKUP//1、成功：call imp //2、失败：objc_msgSend_uncached CacheLookup NORMAL // calls imp or objc_msgSend_uncached#if SUPPORT_TAGGED_POINTERSLNilOrTagged: b.eq LReturnZero // nil check // tagged adrp x10, _objc_debug_taggedpointer_classes@PAGE add x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF ubfx x11, x0, #60, #4 ldr x16, [x10, x11, LSL #3] adrp x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE add x10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF cmp x10, x16 b.ne LGetIsaDone // ext tagged adrp x10, _objc_debug_taggedpointer_ext_classes@PAGE add x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF ubfx x11, x0, #52, #8 ldr x16, [x10, x11, LSL #3] b LGetIsaDone// SUPPORT_TAGGED_POINTERS#endifLReturnZero: // x0 is already zero mov x1, #0 movi d0, #0 movi d1, #0 movi d2, #0 movi d3, #0 ret END_ENTRY _objc_msgSend 通过查看CacheLookup的宏定义代码,得知缓存中寻找的三种形式：CacheHit | CheckMiss | add//1：找到直接返回//2：找不到的话直接checkmiss//3：在其它地方找到的话通过汇编直接add进缓存中。 12345678910111213141516171819202122232425.macro CacheLookup // p1 = SEL, p16 = isa ldp p10, p11, [x16, #CACHE] // p10 = buckets, p11 = occupied|mask#if !__LP64__ and w11, w11, 0xffff // p11 = mask#endif and w12, w1, w11 // x12 = _cmd &amp; mask add p12, p10, p12, LSL #(1+PTRSHIFT) // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT)) ldp p17, p9, [x12] // &#123;imp, sel&#125; = *bucket1: cmp p9, p1 // if (bucket-&gt;sel != _cmd) b.ne 2f // scan more CacheHit $0 // call or return imp 2: // not hit: p12 = not-hit bucket CheckMiss $0 // miss if bucket-&gt;sel == 0 cmp p12, p10 // wrap if bucket == buckets b.eq 3f ldp p17, p9, [x12, #-BUCKET_SIZE]! // &#123;imp, sel&#125; = *--bucket b 1b // loop3: // wrap: p12 = first bucket, w11 = mask add p12, p12, w11, UXTW #(1+PTRSHIFT) // p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT) 查看CacheHit的定义文件即可得知找到imp后可直接返回. 12345678910.macro CacheHit.if $0 == NORMAL TailCallCachedImp x17, x12 // authenticate and call imp.elseif $0 == GETIMP mov p0, p17 AuthAndResignAsIMP x0, x12 // authenticate imp and re-sign as IMP ret // return IMP.elseif $0 == LOOKUP AuthAndResignAsIMP x17, x12 // authenticate imp and re-sign as IMP ret // return imp via x17 查看CheckMiss的定义文件即可得知找不到imp，便调用__objc_msgSend_uncached。 123456789.macro CheckMiss // miss if bucket-&gt;sel == 0.if $0 == GETIMP cbz p9, LGetImpMiss//因为前面声明了CacheLookup NORMAL ，所以会走下面这个判断。.elseif $0 == NORMAL cbz p9, __objc_msgSend_uncached.elseif $0 == LOOKUP cbz p9, __objc_msgLookup_uncached 查看__objc_msgSend_uncached的代码中发现MethodTableLookup的调用，继续跟进，便发现了__class_lookupMethodAndLoadCache3的调用。 12345.macro MethodTableLookup // receiver and selector already in x0 and x1 mov x2, x16 bl __class_lookupMethodAndLoadCache3//这里跳转到C++中。 0x02 分析C++代码继上： 1234567IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)&#123;//第一个YES,接上文，已经完成了isa的初始化，所以为YES.//第一个NO，接上文，通过汇编没有在cache中完成查找，所以为NO。 return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/);&#125; lookUpImpOrForward:是寻找imp的关键函数。runtime中涉及imp的获取底层都会走这个方法。比如class_getMethodImplementation、class_getInstanceMethod、class_getInstanceMethod也是通过lookUpImpOrNil,最后底层走这个方法的。 在下面的方法中大致操作为：1、首先检测缓存，如果cache有的话直接就在缓存中查找返回imp.2、如果类没被创建，便进行实例化操作。3、第一次调用类的时候，执行初始化。4、为了防止并发，再次从缓存中查找。5、遍历当前类的父类，在父类中缓存的imp中查找6、在父类的方法列表中，获取method_t对象。如果找到则缓存查找到的IMP7、如果都没有找到，就尝试动态方法解析和消息转发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = nil; bool triedResolver = NO; runtimeLock.assertUnlocked(); // 如果cache是YES，则从缓存中查找IMP。 if (cache) &#123; // 通过cache_getImp函数查找IMP，查找到则返回IMP并结束调用 // cache_getImp：还是通过汇编来寻找的。 imp = cache_getImp(cls, sel); if (imp) return imp; &#125; runtimeLock.read(); // 判断类是否已经被创建，如果没有被创建，则将类实例化 if (!cls-&gt;isRealized()) &#123; // Drop the read-lock and acquire the write-lock. // realizeClass() checks isRealized() again to prevent // a race while the lock is down. runtimeLock.unlockRead(); runtimeLock.write(); // 对类进行实例化操作 realizeClass(cls); runtimeLock.unlockWrite(); runtimeLock.read(); &#125; // 第一次调用当前类的话，执行initialize的代码 if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; runtimeLock.unlockRead(); // 对类进行初始化，并开辟内存空间 _class_initialize (_class_getNonMetaClass(cls, inst)); runtimeLock.read(); // If sel == initialize, _class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won&apos;t happen. 2778172 &#125; //以下重点！！！ retry: runtimeLock.assertReading();//再次从缓存中获取的原因：//并发-remap(cls) imp = cache_getImp(cls, sel); if (imp) goto done; &#123; // 如果没有从cache中查找到，则从方法列表中获取Method Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) &#123; // 如果获取到对应的Method，则加入缓存并从Method获取IMP log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); imp = meth-&gt;imp; goto done; &#125; &#125; //在父类中找。 // Try superclass caches and method lists. &#123; unsigned attempts = unreasonableClassCount(); // 循环遍历父类。获取这个类的缓存IMP 或 方法列表的IMP for (Class curClass = cls-&gt;superclass; curClass != nil; curClass = curClass-&gt;superclass) &#123; // Halt if there is a cycle in the superclass chain. if (--attempts == 0) &#123; //内存溢出 _objc_fatal(&quot;Memory corruption in class list.&quot;); &#125; // Superclass cache. // 获取父类缓存的IMP imp = cache_getImp(curClass, sel); if (imp) &#123; if (imp != (IMP)_objc_msgForward_impcache) &#123; // Found the method in a superclass. Cache it in this class. // 如果发现父类的方法，并且不再缓存中，在下面的函数中缓存方法 log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; &#125; else &#123; // Found a forward:: entry in a superclass. // Stop searching, but don&apos;t cache yet; call method // resolver for this class first. break; &#125; &#125; // Superclass method list. // 在父类的方法列表中，获取method_t对象。如果找到则缓存查找到的IMP Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; goto done; &#125; &#125; &#125; // No implementation found. Try method resolver once. // 如果没有找到，则尝试动态方法解析 if (resolver &amp;&amp; !triedResolver) &#123; runtimeLock.unlockRead(); //解析。 _class_resolveMethod(cls, sel, inst); runtimeLock.read(); // Don&apos;t cache the result; we don&apos;t hold the lock so it may have // changed already. Re-do the search from scratch instead. //动态解析只能解析一次。 triedResolver = YES; goto retry; &#125; // No implementation found, and method resolver didn&apos;t help. // Use forwarding. // 如果没有IMP被发现，并且动态方法解析也没有处理，则进入消息转发阶段。只有汇编调用，没有源码实现。 imp = (IMP)_objc_msgForward_impcache; cache_fill(cls, sel, imp, inst); done: runtimeLock.unlockRead(); return imp;&#125; 0x03 动态方法解析123456789101112// 如果没有找到，则尝试动态方法解析 if (resolver &amp;&amp; !triedResolver) &#123; runtimeLock.unlockRead(); //解析。 _class_resolveMethod(cls, sel, inst); runtimeLock.read(); // Don&apos;t cache the result; we don&apos;t hold the lock so it may have // changed already. Re-do the search from scratch instead. //动态解析只能解析一次。 triedResolver = YES; goto retry; &#125; _class_resolveMethod: 123456789101112131415161718void _class_resolveMethod(Class cls, SEL sel, id inst)&#123; if (! cls-&gt;isMetaClass()) &#123;//解析实例方法。 // try [cls resolveInstanceMethod:sel] // _class_resolveInstanceMethod：接收消息的是类对象。 _class_resolveInstanceMethod(cls, sel, inst); &#125; else &#123;//解析类方法。 // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] _class_resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; _class_resolveInstanceMethod(cls, sel, inst); &#125; &#125;&#125; 在_class_resolveClassMethod的实现中有如下代码，表示了消息的发送。可知消息的接受者_class_getNonMetaClass(cls, inst)。 123BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(_class_getNonMetaClass(cls, inst), SEL_resolveClassMethod, sel); 进入class_getNonMetaClass的实现中,得知返回的依旧是类对象,这样是方便能够在同一个类中处理，方便管理，而避免了去虚拟的元类中进行改动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static Class getNonMetaClass(Class metacls, id inst)&#123; static int total, named, secondary, sharedcache; runtimeLock.assertLocked(); realizeClass(metacls); total++; // metacls 元类 // metacls 类对象 //判断是否是NSObject if (!metacls-&gt;isMetaClass()) return metacls; // metacls really is a metaclass // special case for root metaclass // where inst == inst-&gt;ISA() == metacls is possible // 判断是否是根元类。 if (metacls-&gt;ISA() == metacls) &#123; Class cls = metacls-&gt;superclass; assert(cls-&gt;isRealized()); assert(!cls-&gt;isMetaClass()); assert(cls-&gt;ISA() == metacls); if (cls-&gt;ISA() == metacls) return cls; &#125; // 类对象 if (inst) &#123; Class cls = (Class)inst; realizeClass(cls); // cls may be a subclass - find the real class for metacls // 元类 != 元类 while (cls &amp;&amp; cls-&gt;ISA() != metacls) &#123; cls = cls-&gt;superclass; realizeClass(cls); &#125; // 最终返回的还是类对象 if (cls) &#123; assert(!cls-&gt;isMetaClass()); assert(cls-&gt;ISA() == metacls); return cls; &#125;#if DEBUG _objc_fatal(&quot;cls is not an instance of metacls&quot;);#else // release build: be forgiving and fall through to slow lookups#endif &#125; 在动态方法解析的过程中，都会调用lookUpImpOrNil来递归查找动态解析方法的imp，而不会发生死递归的原因是在NSObject中实现了动态方法解析，所以最终会找到它。同时我们通过重写NSObject中的+ (BOOL)resolveInstanceMethod:(SEL)sel，在这个方法中通过给没有实现的sel添加imp方法避免崩溃，同时也可以将crash传给后台做崩溃统计等工作。 0x04 消息转发以下的_objc_msgForward_impcache因为苹果闭源是无法看到实现的，我们可以通过定义一个instrumentObjcMessageSends,或者通过反编译函数实现的可执行文件来查看其流程。这里简单介绍一下第二种。 12imp = (IMP)_objc_msgForward_impcache;cache_fill(cls, sel, imp, inst); 通过实现动态方法解析，未实现转发而崩溃的堆栈信息可以看出_objc_msgForward_impcache具体是在CoreFoundation.framework中实现。如图：CoreFoundation.framework的本地地址： 1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation 通过hopper或者ida打开，搜索_CFInitialize，再依次进入_forwarding_prep_0_，__forwarding__。通过查看伪代码，会有以下发现： 1234567891011121314151617181920212223242526272829var_50 = rbx; if (class_respondsToSelector(object_getClass(r12), @selector(_forwardStackInvocation:)) != 0x0) &#123; if (*____forwarding___.onceToken != 0xffffffffffffffff) &#123; dispatch_once(____forwarding___.onceToken, ^ &#123; /* block implemented at ______forwarding____block_invoke */ &#125;); &#125; r13 = [NSInvocation requiredStackSizeForSignature:r14]; rdx = *____forwarding___.invClassSize; r12 = rsp - (rdx + 0xf &amp; 0xfffffffffffffff0); memset(r12, 0x0, rdx); objc_constructInstance(*____forwarding___.invClass, r12); var_40 = r13; [r12 _initWithMethodSignature:r14 frame:var_48 buffer:r12 - (r13 + 0xf &amp; 0xfffffffffffffff0) size:r13]; [var_38 _forwardStackInvocation:r12]; r15 = 0x1; &#125; else &#123; rbx = @selector(forwardInvocation:); if (class_respondsToSelector(object_getClass(r12), rbx) != 0x0) &#123; rdi = r12; r12 = [NSInvocation _invocationWithMethodSignature:r14 frame:var_48]; _objc_msgSend(rdi, rbx); &#125; else &#123; r12 = 0x0; _CFLog(0x4, @&quot;*** NSForwarding: warning: object %p of class &apos;%s&apos; does not implement forwardInvocation: -- dropping message&quot;, 0x0, object_getClassName(0x0), r8, r9, stack[2037]); &#125; var_40 = 0x0; r15 = 0x0; &#125; 如下，代码实现消息转发。 123456789101112131415161718192021// 只有汇编调用 没有源码实现+ (id)forwardingTargetForSelector:(SEL)aSelector&#123; return [super forwardingTargetForSelector:aSelector];&#125;+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; if (aSelector == @selector(walk)) &#123; return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;]; &#125; return [super methodSignatureForSelector:aSelector];&#125;+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123; //在此切面编程 NSString *sto = @&quot;这是参数&quot;; anInvocation.target = [LGStudent class]; [anInvocation setArgument:&amp;sto atIndex:2]; NSLog(@&quot;%@&quot;,anInvocation.methodSignature); anInvocation.selector = @selector(run:); [anInvocation invoke];&#125; 如果没有实现消息转发，我们再根据源码追踪一下走位。进入消息转发的汇编部分。如下： 12345678910111213141516171819202122232425262728293031323334353637STATIC_ENTRY __objc_msgForward_impcache// No stret specialization.b __objc_msgForwardEND_ENTRY __objc_msgForward_impcacheENTRY __objc_msgForwardadrp x17, __objc_forward_handler@PAGEldr p17, [x17, __objc_forward_handler@PAGEOFF]TailCallFunctionPointer x17END_ENTRY __objc_msgForwardENTRY _objc_msgSend_noargb _objc_msgSendEND_ENTRY _objc_msgSend_noargENTRY _objc_msgSend_debugb _objc_msgSendEND_ENTRY _objc_msgSend_debugENTRY _objc_msgSendSuper2_debugb _objc_msgSendSuper2END_ENTRY _objc_msgSendSuper2_debugENTRY _method_invoke// x1 is method triplet instead of SELadd p16, p1, #METHOD_IMPldr p17, [x16]ldr p1, [x1, #METHOD_NAME]TailCallMethodListImp x17, x16END_ENTRY _method_invoke 查看__objc_forward_handler回调 1void *_objc_forward_handler = (void*)objc_defaultForwardHandler; 如下可以见到我们常见的崩溃信息打印的源头了。 12345678910// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel)&#123; _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot; &quot;(no message forward handler is installed)&quot;, class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, object_getClassName(self), sel_getName(sel), self);&#125;]]></content>
      <categories>
        <category>iOS正向</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过dyld源码，详细分析应用加载]]></title>
    <url>%2F2019%2F01%2F14%2Fdyld%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在我们初学iOS的时候，分析一个程序的执行流程都是从main函数开始的。但是在main函数之前其实也做了不少操作，值得我们分析一下。 我们知道一个类的load的方法是先于main函数执行的，通过对load方法设置一个断点，查看调用栈可知程序在加载过程中大致所执行的一些方法。 其中可见dyld（the dynamic link editor），它是苹果的动态链接器，是苹果操作系统一个重要组成部分，在系统内核做好程序准备工作之后，交由dyld负责余下的工作。通过分析dyld的源码,我们来分析dyld做了什么。 准备分析1、通过分析_dyld_start的汇编实现。发现调用了dyldbootstrap::start方法。 12345678# call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue) movl 8(%rbp),%esi # param2 = argc into %esi leaq 16(%rbp),%rdx # param3 = &amp;argv[0] into %rdx movq __dyld_start_static(%rip), %r8 leaq __dyld_start(%rip), %rcx subq %r8, %rcx # param4 = slide into %rcx leaq ___dso_handle(%rip),%r8 # param5 = dyldsMachHeader leaq -8(%rbp),%r9 2、在下载好的dyld源码中搜索dyldbootstrap,在这个命名空间中寻找start方法。在这个方法中，通过slideOfMainExecutable得到因ASLR产生的偏移。通过rebaseDyld重绑定。通过__guard_setup来栈溢出保护。 123uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader, uintptr_t* startGlue) 这个start的方法的返回值是调用了一个main函数,将start的一些值作为参数传到main。 1return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue); 3、dyld也可以看做一个程序的执行，它的main函数和我们日常开发应用的main函数类似，都可以看做程序的入口。接下来我们主要便是分析main函数的实现。 123_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue) 加载过程0x01 配置环境，设置环境变量等 设置上下文 1setContext(mainExecutableMH, argc, argv, envp, apple); 配置进程是否受限 1configureProcessRestrictions(mainExecutableMH); 检查环境变量 1checkEnvironmentVariables(envp); 根据Xcode设置的环境变量，来打印程序相应参数。 1234if ( sEnv.DYLD_PRINT_OPTS ) printOptions(argv);if ( sEnv.DYLD_PRINT_ENV ) printEnvironmentVariables(envp); 会打印程序相关的目录、用户级别、插入的动态库、动态库的路径等。 12345678910111213141516171819202122opt[0] = &quot;/var/containers/Bundle/Application/731D64D1-8B04-491B-A512-4010011413E6/dyld.app/dyld&quot;CA_DEBUG_TRANSACTIONS=0TMPDIR=/private/var/mobile/Containers/Data/Application/EF8F63AD-B59A-42E7-92EE-076BC9F664D0/tmp__CF_USER_TEXT_ENCODING=0x1F5:0:0SHELL=/bin/shSQLITE_ENABLE_THREAD_ASSERTIONS=1OS_ACTIVITY_DT_MODE=YESHOME=/private/var/mobile/Containers/Data/Application/EF8F63AD-B59A-42E7-92EE-076BC9F664D0DYLD_PRINT_TO_STDERR=YESCFFIXED_USER_HOME=/private/var/mobile/Containers/Data/Application/EF8F63AD-B59A-42E7-92EE-076BC9F664D0NSUnbufferedIO=YESPATH=/usr/bin:/bin:/usr/sbin:/sbinLOGNAME=mobileXPC_SERVICE_NAME=UIKitApplication:dyoung.dyld[0x1b53][62]DYLD_INSERT_LIBRARIES=/Developer/usr/lib/libBacktraceRecording.dylib:/Developer/usr/lib/libMainThreadChecker.dylib:/Developer/Library/PrivateFrameworks/DTDDISupport.framework/libViewDebuggerSupport.dylibCLASSIC=0DYLD_PRINT_OPTS=1DYLD_PRINT_ENV=1USER=mobileXPC_FLAGS=0x1CA_ASSERT_MAIN_THREAD_TRANSACTIONS=0DYLD_LIBRARY_PATH=/usr/lib/system/introspection 通过getHostInfo获取machO头部获取当前运行架构的信息。 1static void getHostInfo(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide) 0x02 加载共享缓存库。 判断共享缓存库是否被禁用。iOS cannot run without shared region，注释说明iOS平台下是不能被禁用的。 1checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide); 通过mapSharedCache()函数加载、进入函数内部其主要实现是loadDyldCache这个函数。其中作了如下三种判断 123456789101112131415161718 if ( options.forcePrivate ) &#123; // mmap cache into this process only //只加载到当前缓存。 return mapCachePrivate(options, results); &#125; else &#123; // fast path: when cache is already mapped into shared region //快速路径，如果已经加载的话就不处理了。 bool hasError = false; if ( reuseExistingCache(options, results) ) &#123; hasError = (results-&gt;errorMessage != nullptr); &#125; else &#123; // slow path: this is first process to load cache //第一次加载的话通过它来加载。 hasError = mapCacheSystemWide(options, results); &#125; return hasError;&#125; 0x03 实例化主程序(Mach0，程序的可执行文件) 实例化过程：instantiateFromLoadedImage 123456789101112static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)&#123; // try mach-o loader //isCompatibleMachO 是检查mach-o的subtype是否是当前cpu可以支持 if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123; ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext); addImage(image);//将image添加到imagelist。所以我们在Xcode使用image list命令查看的第一个便是我们的machO return (ImageLoaderMachO*)image; &#125; throw &quot;main executable not a known format&quot;;&#125; 0x04 加载插入库 通过loadInsertedDylib方法执行插入动态库的加载。在实现中调用load方法返回imageLoader对象， imageLoader是一个抽象基类，专门用于辅助加载特定可执行文件格式的类，对于程序中需要的依赖库、插入库，会创建一个对应的image对象，对这些image进行链接，调用各image的初始化方法等等，包括对runtime的初始化。 123456// load any inserted libraries if ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123;//遍历DYLD_INSERT_LIBRARIES的环境变量。 for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib); &#125; 0x05 链接主程序，并加载系统和第三方的动态库 在 main中通过link链接主程序。 12//main 函数中link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); 内部通过imageLoader的实例对象去调用link方法。 12//image调用linkimage-&gt;link(gLinkContext, forceLazysBound, false, neverUnload, loaderRPaths, path); 递归加载我们所需要的依赖的系统库和第三方库。 1this-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath); 对依赖库进行重定位。相当于加上ASLR滑块。 1this-&gt;recursiveRebase(context); 递归绑定符号表和弱绑定。 绑定就是将这个二进制调用的外部符号进行绑定的过程。比如我们objc代码中需要使用到NSObject, 即符号OBJC_CLASS$_NSObject，但是这个符号又不在我们的二进制中，在系统库 Foundation.framework中，因此就需要binding这个操作将对应关系绑定到一起。lazyBinding就是在加载动态库的时候不会立即binding, 当第一次调用这个方法的时候再实施binding。 做到的方法也很简单： 通过dyld_stub_binder 这个符号来做。lazy binding的方法第一次会调用到dyld_stub_binder, 然后dyld_stub_binder负责找到真实的方法，并且将地址bind到桩上，下一次就不用再bind了。 1this-&gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload); 1this-&gt;weakBind(context); 插入动态库。 12345678910111213if ( sInsertedDylibCount &gt; 0 ) &#123;//有的话就开始链接加载。 for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1];//1过滤到主程序。 link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); image-&gt;setNeverUnloadRecursive(); &#125; // only INSERTED libraries can interpose // register interposing info after all inserted libraries are bound so chaining works for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1]; image-&gt;registerInterposing(gLinkContext); &#125;&#125; 0x06 初始化函数，承前启后 一、dyld流程分析-&gt; 在main函数中我们进入initializeMainExecutable-&gt;runInitializers初始化主程序-&gt;processInitializers-&gt;recursiveInitialization循环初始化-&gt;关键函数 ：notifySingle。在这个方法中调用了objc的loadImages。通过command+shift+o全局搜索寻找实现。 1static void notifySingle(dyld_image_states state, const ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo) 发现一个函数指针的调用： 1(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader()); 通过在本文件搜索sNotifyObjCInit函数指针，我们找到了赋值的地方。 123void registerObjCNotifiers(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)&#123; sNotifyObjCInit = init;//赋值函数。 全局搜索registerObjCNotifiers调用的地方 123456void _dyld_objc_notify_register(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)&#123; dyld::registerObjCNotifiers(mapped, init, unmapped);&#125; 再次全局搜索_dyld_objc_notify_register便找不到这个方法调用。于是我们通过Xcode设置符号断点来分析。如图所示，我们则能推断出这个方法的调用是在runtime中。 二、runtime流程分析分析runtime源码。可知上面的函数是在其初始化的时候进行调用的。load_images赋值到dyld中的sNotifyObjCInit指针。 1234567891011121314void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);&#125; 在load_images中，完成call_load_methods的调用。 12345678910111213141516load_images(const char *path __unused, const struct mach_header *mh)&#123; // Return without taking locks if there are no +load methods here. if (!hasLoadMethods((const headerType *)mh)) return; recursive_mutex_locker_t lock(loadMethodLock); // Discover load methods &#123; mutex_locker_t lock2(runtimeLock); prepare_load_methods((const headerType *)mh); &#125; // Call +load methods (without runtimeLock - re-entrant) call_load_methods();&#125; 在call_load_methods中，通过doWhile循环来调用call_class_loads实现每个类的load方法。 1234567891011121314151617181920212223242526272829void call_load_methods(void)&#123; static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; // 1. Repeatedly call class +loads until there aren&apos;t any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125; 三、_ _ attribute_ _((constructor)) 是GCC的扩展语法（黑魔法），由它修饰过的函数，会在main函数之前调用。原理是在ELF的.ctors段增加一条函数引用，加载器在执行main函数前，检查.ctror section，并执行里面的函数。 继续dyld分析。在imageLoader.cpp文件中，notifySingle调用之后，接着调用了doInitialization方法。 其中doModInitFunctions会调用machO文件中_mod_init_func段的函数，也就是我们在文件中所定义的全局C++构造函数。 123456789101112bool ImageLoaderMachO::doInitialization(const LinkContext&amp; context)&#123; CRSetCrashLogMessage2(this-&gt;getPath()); // mach-o has -init and static initializers doImageInit(context); doModInitFunctions(context); CRSetCrashLogMessage2(NULL); return (fHasDashInit || fHasInitializers);&#125; 通过以上分析加载流程我们可得知函数的执行顺序为： 1load -&gt; attribute((constructor)) -&gt; main -&gt; initialize 0x07 寻找应用程序主函数入口最后return,dyld的main函数结束。 12// find entry point for main executableresult = (uintptr_t)sMainExecutable-&gt;getThreadPC(); 至此，程序进入了main函数，开启了我们熟知的一切。]]></content>
      <categories>
        <category>iOS正向</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS应用脱壳(解密)的几种方式]]></title>
    <url>%2F2018%2F12%2F27%2FiOS%E5%BA%94%E7%94%A8%E8%84%B1%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[我们日常开发提交给Appstore发布的App，都经过官方保护而加密，这样可以保证机器上跑的应用是苹果审核过的，也可以管理软件授权。经过App Store加密的应用，我们无法通过Hopper等反编译静态分析，也无法Class-Dump，在逆向分析过程中需要对加密的二进制文件进行解密才可以进行静态分析，这一过程就是大家熟知的砸壳（脱壳） 一、Clutch 由KJCracks开发的一款开源砸壳工具。 具体操作1、使用Clutch，下载最新的release版本,可得到一个名为Clutch-2.0.4的胖二进制文件。2、通过usb登录越狱设备。3、通过命令scp -P 12345 Clutch-2.0.4 root@localhost:/usr/bin将其拷贝到越狱设备的指定目录下。可通过mv Clutch-2.0.4 Clutch对其重命名。 4、查看Clutch的可执行权限。没有的话就chmod +x Clutch添加权限即可。5、进入到越狱设备的命令行操作界面。通过Clutch命令可查看相关命令帮助信息。 1234567891011Dyoung5s:~ root# pwd/var/rootDyoung5s:~ root# ClutchUsage: Clutch [OPTIONS]-b --binary-dump &lt;value&gt; Only dump binary files from specified bundleID-d --dump &lt;value&gt; Dump specified bundleID into .ipa file-i --print-installed Print installed applications --clean Clean /var/tmp/clutch directory --version Display version and exit-? --help Display this help and exit-n --no-color Print with colors disabled 6、Clutch -i 显示可砸壳的应用列表。 12345678910Dyoung5s:~ root# Clutch -iInstalled apps:1: 微博国际版 &lt;com.weibo.international&gt;2: 淘宝-双十二购物，移动生活社区 &lt;com.taobao.taobao4iphone&gt;3: 今日头条极速版 &lt;com.ss.iphone.article.lite&gt;4: QQ &lt;com.tencent.mqq&gt;5: DingTalk &lt;com.laiwang.DingTalk&gt;6: 酷狗音乐-就是歌多 &lt;com.kugou.kugou1002&gt;7: 抖音短视频 &lt;com.ss.iphone.ugc.Aweme&gt;8: 爱思助手 &lt;com.diary.mood&gt; 7、Clutch -d 4选择要砸壳的应用，并进行砸壳，成功后有如下提示。将其拷贝出来即可。我们也可以通过otool -l查看其cryptid字段以验证是否砸壳成功。 二、dumpdecrypted 通过建立一个名为dumpdecrypted.dylib的动态库，插入目标应用实现脱壳。 1、下载dumpdecrypted，并通过make命令编译生成dylib库。2、通过命令scp -P 12345 dumpdecrypted.dylib root@localhost:~/将动态库拷贝越狱设备的指定目录。 3、通过ps -A查看当前进程，并通过如下命令将其动态库插入到指定进程中。即可生成对应进程应用的MachO文件。 12//后面加上的进程路径。DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/A8CC18F5-9213-482E-B145-C36EFE9ACED0/DingTalk.app/DingTalk 三、frida-ios-dump安装1、下载pip 1sudo easy_install pip 2、通过pip下载frida_tools 123sudo -H pip install frida_tools//如果报下图中的错误则更换为另外一条命令。sudo pip install six --upgrade --ignore-installed six 3、直接clonefrida-ios-dump到本地目录，进入目录可发现dump.py脚本文件。 4、修改dump.py文件中的如下信息，确保与越狱设备信息匹配。 5、在越狱设备中添加https://build.frida.re源，并且安装Frida插件. dump应用将脱壳应用在设备上置于运行状态。进入脚本所在文件夹，通过./dump.py 微信便可成功脱壳应用。成功后会在脚本文件所在文件夹中生成ipa包。 以上dump时的操作可写成脚本,将frida-ios-dump文件夹放置sh脚本文件的同级目录中。编写脚本，并配置环境变量即可。 12//脚本内容:dump.py的路径 $1 遇到的一些坑：1、No module named xxx。 通过pip install --user xxx下载即可。 2、from scp import xxx，同上执行pip install --user xxx即可。 3、生成ipa，存放到脚本文件所在文件夹时没有写的权限。可直接对文件夹执行sudo chmod -R 777 文件夹路径即可。 四、lldb手动dump准备1、在手机中配置好debugserver。2、通过以下命令导出需要dump应用的可执行文件到当前路径。xxxx代表应用进程路径。 1scp -P 12345 root@localhost:xxxx ./ 3、查看瘦身后的可执行文件的加密信息。并记录。 1234● otool -l Aweme_arm64 | grep cry cryptoff 16384 cryptsize 52527104 cryptid 1 分析：cryptoff：指加密文件的头所对应的偏移。这个数字之前代表着可执行文件的header。cryptsize: 加密的数据长度，我们需要把这段时间拷贝出来。 实操1、开启debugserver服务，依附到我们想要dump应用的进程中。 1debugserver *:9393 -a Aweme 2、电脑进入lldb调试环境，连接到对应的debugserver端口。 1process connect [connect://localhost:9393](connect://localhost:9393) 3、通过image list指令拿到可执行文件的头地址，加上之前的cryptoff得到需要拷贝数据的起始地址。 4、按字节读取内存中的可执行文件，并拷贝到电脑。（耗时动作） 12345//--force:按字节读取。//0x00000001000c4000+16384：需要拷贝内容的起始地址。//52527104：需要拷贝内容的大小。//./decrypted.bin ： 在当前目录下生成一个名为decrypted.bin的二进制包。memory read --force --outfile ./decrypted.bin --binary --count 52527104 0x00000001000c4000+16384 5、将二进制文件包替换之前拷贝出来的可执行文件中的对应部分，得到一个新的可执行文件。 1234//dd：用指定大小的文件写到另一个文件当中。//bs：一个一个字节写入//conv：指定转换文件的方式。dd seek=16384 bs=1 conv=notrunc if=./decrypted.bin of=./Aweme_arm64 6、通过otool -l查看新的可执行文件，得知cryptid仍为1,这里是因为我们并没有对header文件作修改，所以字段的值仍保持之前加密的键值。但是可执行文件的内容却被我们解密了的。可以通过class-dump验证。 7、通过Mach0View 修改cryptid的值为0。如果不修改class-dump会不成功。因为这个工具首先会拿到header获取cryptid的值，如果是已加密的话就会放弃后面的dump工作了。 8、通过class-dump -H Aweme_arm64 -o ./AwemeHeaders能导出应用的头文件，便可证明lldb手动脱壳成功。 补充frida_tools的一些使用1、配置端口映射。通过frida-ps列出当前应用进程。通过usb连接好手机后，通过frida-ps -U列出usb设备的应用进程。2、通过frida -U 微信附加进程到微信。3、执行ObjC可拿到附加进程应用的所有Object-C对象。 插入自定义动态库到指定应用 通过这样的操作，进程没有被污染，在以后的每次执行时候不会执行我们所插入的动态库的方法。这里只相当于一次性插入。上文的dumpdecrypted便是用到了这样的原理。 1、使用Xcode生成framework文件。通过以下命令拷贝到越狱设备中。 1scp -r -P 12345 DyInsert.framework/ root@localhost:~/ 2、通过以下命令将动态库插入到指定进程即可。 1DYLD_INSERT_LIBRARIES=DyInsert.framework/DyInsert /var/mobile/Containers/Bundle/Application/4560ADA4-9AE4-4E9D-BE84-ABF666B12A7A/WeChat.app/WeChat]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RSA原理探究及命令行实践]]></title>
    <url>%2F2018%2F10%2F04%2Frsa%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[RSA算法是非对称加密算法,在1977年被罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的,故取名为RSA非对称加密算法,而今在计算机数据加密领域以及电子商业中广泛使用。 RSA数学原理及推导流程 离散对数——欧拉函数——欧拉定理——模反元素——迪菲赫尔曼密钥交换——RSA诞生。 1.离散对数离散对数其实是一种数学规律，即存在一个数m，m的k次方模以n，会存在一个规律，那就是值在1在n-1之间，此时我们就称m为n的原根。比如：3^k mod 17 的值会在1~16这个范围，所以3是17的原根。 2.欧拉函数求一个正整数，比它小的正整数中，有多少个与它构成互质关系，这个值就是欧拉函数。用φ()表示.互质关系：如果两个正整数，除了1之外没有，没有其它共同的公因数。 特点： 当n为质数时，φ(n) = n-1 如果n可以分解为两个质数的乘积时，φ(ab) = φ(a) φ(b)以上可得： 1φ(n) = φ(a)*φ(b) = (a-1)*(b-1) 3.欧拉定理如果两个正整数m和n互质，那么m的φ(n)次方减去1，可以被n整除。 1m^φ(n) mod n = 1 ==&gt;推导： 12341、等式两边同时乘以K，得：m^k*φ(n) mod n = 12、等式两边同时乘以m，得：m^(k*φ(n)+1) mod n = 1 费马小定理：在欧拉函数条件下，加上m和n都是质数的条件。即上述公式可表示为： 1m^(n-1) mod n = 1 4.模反元素如果两个正整数e和x互质，一定存在整数d，使得ed-1被x整除，即d就是e相对于x的模反元素。如下表示： 1234//e、x互质//d是e相对于x的模反元素。e*d mod x = 1 ==&gt; e*d = kx+1 ==&gt;分析模反元素的推导结果对比欧拉定理的推导结果: 1e*d = kx+1 &lt;==&gt; m^(k*φ(n)+1) mod n = m 替换k*φ(n)+1 为e*d 得： 123//m&lt;n//d是e相对于φ(n)的模反元素。m^(e*d) mod n = m 5.迪菲赫尔曼密钥交换用于将上述公式拆分，具体过程如图所示 ==&gt;由上推导：m^e mod n = c –&gt; c^d mod n = m^e*d mod n = m，得： 6.RSA加密公式 公式成立条件：m&lt;nd是e相对于φ(n)的模反元素。 12m^e mod n = c //公钥加密c^d mod n = n //私钥解密 公钥：n和e （公开）私钥：n和d安全说明：根据公式：e*d = kφ(n)+1，目前n和e公开，要想求出d，就得知道φ(n)，所以需要将n因式分解才行。为了避免被破解，所以n会取很大很大的整数。一般为1024个二进制位（目前已知人类破解极限是768位），所以公式成立需要六个数: 1p1、p2、n、φ(n)、e、d 终端操作RSA加密 生成私钥 1openssl genrsa -out privite.pem 2048 查看私钥信息：cat privite.pem ，得到如下Base64编码。（因为base64是按照6个比特位来加密的，所以最后不足6个比特位的时候就用=表示） 输入明文 1openssl rsa -in privite.pem -text -out privite.txt 打开txt：open private.txt，可见下图框中标识publicExponent: 65537 (0x10001)，其中65537代表RSA加密公式中的e. 通过私钥生成对应公钥 1openssl rsa -in privite.pem -pubout -out public.pem 通过公钥加密数据，私钥解密数据。 1234//公钥加密openssl rsautl -encrypt -in message.txt -inkey public.pem -pubin -out enc.txt//私钥解密openssl rsautl -decrypt -in enc.txt -inkey privite.pem -out dec.txt 通过私钥加密数据(签名),公钥解密。 1234//加密。openssl rsautl -sign -in message.txt -inkey privite.pem -out enc.txt//解密openssl rsautl -verify -in enc.txt -inkey public.pem -pubin -out dec.txt RSA特点: 相对安全。由于是非对称加密，密钥不用传递。 加密效率低。 加密数据小。 终端生成证书1.生产csr文件（mac公钥）1openssl req -new -key private.pem -out rsacert.csr 2.生成crt文件（base64）根据上述csr文件及私钥文件而来 1openssl x509 -req -days 3650 -in rsacert.csr -signkey private.pem -out rsacert.crt 3.生成der文件(公钥)根据上述crt文件而来。 1openssl x509 -outform der -in rsacert.crt -out rsacert.der 4.生成p12文件这里会提示输入p12证书的密码。 1pkcs12 -export -out p.p12 -inkey privite.pem -in rsacert.crt 补充： ios系统不直接支持rsa，但是支持x509(一种证书标准,主要定义了证书中应该包含哪些内容)的支持认证。同样的X.509证书,可能有不同的编码格式。PEM编码和 DER编码相关文件扩展名：CRT，CER，KEY，CSR（证书签名请求，相当于一个公钥，私钥是放在服务端的 ） Xcode代码演示 通过上述生成的.der和.p12文件，用RSA加密及解密文件。 将der证书和p12证书导入到xcode项目中，通过rsa第三方工具类，完成加解密过程。 12345//1、加载公钥 [[RSACryptor sharedRSACryptor] loadPublicKey:[[NSBundle mainBundle] pathForResource:@&quot;rsacert.der&quot; ofType:nil]] ; //2、加载私钥 [[RSACryptor sharedRSACryptor] loadPrivateKey:[[NSBundle mainBundle] pathForResource:@&quot;p.p12&quot; ofType:nil] password:@&quot;123456&quot;]; 1234567891011-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; //加密 NSData * ret = [[RSACryptor sharedRSACryptor] encryptData:[@&quot;hello&quot; dataUsingEncoding:NSUTF8StringEncoding]]; //编码 NSString * base64 = [ret base64EncodedStringWithOptions:0]; NSLog(@&quot;%@&quot;,base64); //解密 NSData * jiemi = [[RSACryptor sharedRSACryptor] decryptData:ret]; NSLog(@&quot;%@&quot;,[[NSString alloc] initWithData:jiemi encoding:NSUTF8StringEncoding]);&#125; 参考资源链接Objective-C-RSA那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)]]></content>
      <categories>
        <category>iOS正向</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UIBezierPath - 基础API介绍实践]]></title>
    <url>%2F2017%2F05%2F14%2FUIBezierPath-%E5%85%A8%E9%9D%A2%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[UIKit中的UIBezierPath是Core Graphics框架关于path的一个封装。可以创建基于矢量的路径，例如椭圆或者矩形，或者有多个直线和曲线段组成的形状. Core Graphics 的基本介绍与使用 属性 lineWidth：线宽属性定义了 UIBezierPath 对象中绘制的曲线规格. 默认为: 1.0 lineCapStyle：应用于曲线的终点和起点. 该属性在一个闭合子路经中是无效果的. 默认为: kCGLineCapButt 枚举值： 12345 typedef CF_ENUM(int32_t, CGLineCap) &#123; kCGLineCapButt, kCGLineCapRound, kCGLineCapSquare&#125;; 对应样式： lineJoinStyle：曲线连接点的样式. 枚举值： 12345 typedef CF_ENUM(int32_t, CGLineJoin) &#123; kCGLineJoinMiter, kCGLineJoinRound, kCGLineJoinBevel&#125;; 对应样式： miterLimit：两条线交汇处内角和外角之间的最大距离, 仅当连接点样式为 kCGLineJoinMiter时生效. 图解如下 flatness：渲染精度（表示真实曲线的点和渲染曲线的点的最大允许距离）。值越小，精度越高。default：0.6。 usesEvenOddFillRule：是否使用基偶填充规则。两种规则的详细介绍 12设置为 YES, 则路径将会使用 基偶规则 (even-odd) 进行填充.设置为 NO, 则路径将会使用 非零规则 (non-zero) 规则进行填充. CGPath：一个不可变的 CGPathRef 对象 1他可以传入 CoreGraphics 提供的函数中你可以是用 CoreGraphics 框架提供的方法创建一个路径, 并给这个属性赋值, 当时设置了一个新的路径后, 这个将会对你给出的路径对象进行 Copy 操作 currentPoint：下一条绘制的直线或曲线的起始点。如果当前路径为空, 那么该属性的值将会是 CGPointZero bounds：路径覆盖的矩形区域。该属性描述的是一个能够完全包含路径中所有点的一个最小的矩形区域. 该区域包含二次贝塞尔曲线和三次贝塞尔曲线的控制点. empty：路径是否为空。 &lt;注&gt;： 就算你仅仅调用了 moveToPoint 方法那么当前路径也被看做不为空. 创建实例对象 创建 1+ (instancetype) bezierPath; by 矩形 12345/** * 该方法将会创建一个闭合路径, 起始点是 rect 参数的的 origin, 并且按照顺时针方向添加直线, 最终形成矩形 * @param rect: 矩形路径的 Frame */+ (instancetype)bezierPathWithRect:(CGRect)rect; by 椭圆 12345/** * 该方法将会创建一个闭合路径, 该方法会通过顺时针的绘制贝塞尔曲线, 绘制出一个近似椭圆的形状. 如果 rect 参数指定了一个矩形, 那么该 UIBezierPath 对象将会描述一个圆形. * @param rect: 矩形路径的 Frame */+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect; by 圆角矩形： 1234567/** * 该方法将会创建一个闭合路径, 该方法会顺时针方向连续绘制直线和曲线. 当 rect 为正方形时且 cornerRadius 等于边长一半时, 则该方法会描述一个圆形路径. * @param rect: 矩形路径的 Frame * @param cornerRadius: 矩形的圆角半径 */+ (instancetype) bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius; 可以指定矩形的哪个角为圆角： 123456789/** * 该方法将会创建一个闭合路径, 该方法会顺时针方向连续绘制直线和曲线. * @param rect: 矩形路径的 Frame * @param corners: UIRectCorner 枚举类型, 指定矩形的哪个角变为圆角 * @param cornerRadii: 矩形的圆角半径 */+ (instancetype) bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii; by 圆弧 123456789101112131415/** * 该方法会创建出一个开放路径, 创建出来的圆弧是圆的一部分. 在默认的坐标系统中, 开始角度 和 结束角度 都是基于单位圆的(看下面这张图). 调用这个方法之后, currentPoint 将会设置为圆弧的结束点. * 举例来说: 指定其实角度为0, 指定结束角度为π, 设置 clockwise 属性为 YES, 将会绘制出圆的下半部分. * 然而当我们不修改起始角度 和 结束角度, 我们仅仅将 clockwise 角度设置为 NO, 则会绘制出来一个圆的上半部分. * @param center: 圆心 * @param radius: 半径 * @param startAngle: 起始角度 * @param endAngle: 结束角度 * @param clockwise: 是否顺时针绘制 */+ (instancetype) bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise; ) by CGPath 1+ (instancetype) bezierPathWithCGPath:(CGPathRef)CGPath; by 反方向Path（这里的方向是指绘制方向）。 12345/** * @return: 返回一个新的 UIBezierPath 对象, 形状和原来路径的形状一样, * 但是绘制的方向相反. */- (UIBezierPath *) bezierPathByReversingPath; 构造或添加路径 将对象的currentPoint移到某个点。（对于大多数构造路径相关的方法而言, 在你绘制直线或曲线之前, 需要先调用这个方法.） 12345678/** * 如果当前有正在绘制的子路径, 该方法则会隐式的结束当前路径, * 并将 currentPoint 设置为指定点. 当上一条子路径被终止, 该方法 * 实际上并不会去闭合上一条子路径. 所以上一条自路径的起始点 和 * 结束点并没有被链接. * @param point: 当前坐标系统中的某一点 */- (void)moveToPoint:(CGPoint)point; 追加 一条直线 123456789/** * 该方法将会从 currentPoint 到 指定点 链接一条直线. * Note: 在追加完这条直线后, 该方法将会更新 currentPoint 为 指定点 * 调用该方法之前, 你必须先设置 currentPoint. 如果当前绘制路径 * 为空, 并且未设置 currentPoint, 那么调用该方法将不会产生任何 * 效果. * @param point: 绘制直线的终点坐标, 当前坐标系统中的某一点 */- (void)addLineToPoint:(CGPoint)point; 追加 一条圆弧 1234567891011121314/** * 该方法将会从 currentPoint 添加一条指定的圆弧. * 该方法的介绍和构造方法中的一样. 请前往上文查看 * @param center: 圆心 * @param radius: 半径 * @param startAngle: 起始角度 * @param endAngle: 结束角度 * @param clockwise: 是否顺时针绘制 */- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise NS_AVAILABLE_IOS(4_0); 追加 一条三次贝塞尔曲线 1234567891011121314/** * 该方法将会从 currentPoint 到 指定的 endPoint 追加一条三次贝塞尔曲线. * 三次贝塞尔曲线的弯曲由两个控制点来控制. 如下图所示 * Note: 调用该方法前, 你必须先设置 currentPoint, 如果路径为空, * 并且尚未设置 currentPoint, 调用该方法则不会产生任何效果. * 当添加完贝塞尔曲线后, 该方法将会自动更新 currentPoint 为 * 指定的结束点 * @param endPoint: 终点 * @param controlPoint1: 控制点1 * @param controlPoint2: 控制点2 */- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2; 图解如下： ) 追加一条二次贝塞尔曲线： 12345678910111213/** * 该方法将会从 currentPoint 到 指定的 endPoint 追加一条二次贝塞尔曲线. * currentPoint、endPoint、controlPoint 三者的关系最终定义了二次贝塞尔曲线的形状. * 二次贝塞尔曲线的弯曲由一个控制点来控制. 如下图所示 * Note: 调用该方法前, 你必须先设置 currentPoint, 如果路径为空, * 并且尚未设置 currentPoint, 调用该方法则不会产生任何效果. * 当添加完贝塞尔曲线后, 该方法将会自动更新 currentPoint 为 * 指定的结束点 * @param endPoint: 终点 * @param controlPoint: 控制点 */- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint; 图解如下： 追加 UIBezierPath 实例对象 12345/** * 该方法将会在当前 UIBezierPath 对象的路径中追加 * 指定的 UIBezierPath 对象中的内容. */- (void)appendPath:(UIBezierPath *)bezierPath; 虚线路径 构建一条虚线路径： 123456789101112131415161718/** * @param pattern: 该属性是一个 C 语言的数组, 其中每一个元素都是 CGFloat * 数组中的元素代表着线段每一部分的长度, 第一个元素代表线段的第一条线, * 第二个元素代表线段中的第一个间隙. 这个数组中的值是轮流的. 来解释一下 * 什么叫轮流的. * 举个例子: 声明一个数组 CGFloat dash[] = @&#123;3.0, 1.0&#125;; * 这意味着绘制的虚线的第一部分长度为3.0, 第一个间隙长度为1.0, 虚线的 * 第二部分长度为3.0, 第二个间隙长度为1.0. 以此类推. * @param count: 这个参数是 pattern 数组的个数 * @param phase: 这个参数代表着, 虚线从哪里开始绘制. * 举个例子: 这是 phase 为 6. pattern[] = @&#123;5, 2, 3, 2&#125;; 那么虚线将会 * 第一个间隙的中间部分开始绘制, 如果不是很明白就请继续往下看, * 下文实战部分会对虚线进行讲解. */- (void)setLineDash:(const CGFloat *)pattern count:(NSInteger)count phase:(CGFloat)phase; 获取虚线的模式: 12345678910/** * 该方法可以重新获取之前设置过的虚线样式. * Note: pattern 这个参数的容量必须大于该方法返回数组的容量. * 如果无法确定数组的容量, 那么可以调用两次该方法, 第一次 * 调用该方法的时候, 传入 count 参数, 然后在用 count 参数 * 来申请 pattern 数组的内存空间. 然后再第二次正常的调用该方法 */- (void)getLineDash:(CGFloat *)pattern count:(NSInteger *)count phase:(CGFloat *)phase; 尝试Demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void) typeDashLine &#123; // 1. 先创建三条路径, 有对比更有助于理解 UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint: CGPointMake(80, 40)]; [path addLineToPoint: CGPointMake(self.frame.size.width - 40, 40)]; path.lineWidth = 2; UIBezierPath *path1 = [UIBezierPath bezierPath]; [path1 moveToPoint: CGPointMake(80, 80)]; [path1 addLineToPoint: CGPointMake(self.frame.size.width - 40, 80)]; path1.lineWidth = 2; UIBezierPath *path2 = [UIBezierPath bezierPath]; [path2 moveToPoint: CGPointMake(80, 120)]; [path2 addLineToPoint: CGPointMake(self.frame.size.width - 40, 120)]; path2.lineWidth = 2; // 2. 这部分是配置三条路径虚线的规格, 重点主要是这部分. CGFloat dashLineConfig[] = &#123;8.0, 4.0&#125;; [path setLineDash: dashLineConfig count: 2 phase: 0]; CGFloat dashLineConfig1[] = &#123;8.0, 4.0, 16.0, 8.0&#125;; [path1 setLineDash: dashLineConfig1 count: 4 phase: 0]; CGFloat dashLineConfig2[] = &#123;8.0, 4.0, 16.0, 8.0&#125;; [path2 setLineDash: dashLineConfig2 count: 4 phase: 12]; // 3. 绘制 [[UIColor orangeColor] set]; [path stroke]; [path1 stroke]; [path2 stroke];&#125; 显示效果： ) 更改路径 关闭当前子路径 123456/** * 该方法将会从 currentPoint 到子路经的起点 绘制一条直线, * 以此来关闭当前的自路径. 紧接着该方法将会更新 currentPoint * 为 刚添加的这条直线的终点, 也就是当前子路经的起点. */- (void)closePath; 删除 UIBezierPath 对象中的所有点, 效果也就等同于删除了所有子路经： 1- (void)removeAllPoints; 剪切路径 123456789101112131415/** * 该方法将会修改当前绘图上下文的可视区域. * 当调用这个方法之后, 会导致接下来所有的渲染 * 操作, 只会在剪切下来的区域内进行, 区域外的 * 内容将不会被渲染. * 如果你希望执行接下来的绘图时, 删除剪切区域, * 那么你必须在调用该方法前, 先使用 CGContextSaveGState 方法 * 保存当前的绘图状态, 当你不再需要这个剪切区域 * 的时候, 你只需要使用 CGContextRestoreGState 方法 * 来恢复之前保存的绘图状态就可以了. * @param blendMode: 混合模式决定了如何和 * 已经存在的被渲染过的内容进行合成 * @param alpha: 填充路径时的透明度 */- (void)addClip; 放射变换操作 12345/** * 该方法将会直接对路径中的所有点进行指定的放射 * 变换操作. */- (void)applyTransform:(CGAffineTransform)transform; 绘制相关 填充路径： 1234567/** * 该方法当前的填充颜色 和 绘图属性对路径的封闭区域进行填充. * 如果当前路径是一条开放路径, 该方法将会隐式的将路径进行关闭后进行填充 * 该方法在进行填充操作之前, 会自动保存当前绘图的状态, 所以我们不需要 * 自己手动的去保存绘图状态了. */- (void)fill; 使用混合模式填充路径 123456789101112/** * 该方法当前的填充颜色 和 绘图属性 (外加指定的混合模式 和 透明度) * 对路径的封闭区域进行填充. 如果当前路径是一条开放路径, 该方法将 * 会隐式的将路径进行关闭后进行填充 * 该方法在进行填充操作之前, 会自动保存当前绘图的状态, 所以我们不需要 * 自己手动的去保存绘图状态了. * * @param blendMode: 混合模式决定了如何和已经存在的被渲染过的内容进行合成 * @param alpha: 填充路径时的透明度 */- (void)fillWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha; 绘制路径：（一般用于将路径相关设置完成后的最后一步操作）. 1- (void)stroke; 判断方法 是否包含某个点 123456789101112/** * 该方法返回一个布尔值, 当曲线的覆盖区域包含 * 指定的点(内部点)， 则返回 YES, 否则返回 NO. * Note: 如果当前的路径是一个开放的路径, 那么 * 就算指定点在路径覆盖范围内, 该方法仍然会 * 返回 NO, 所以如果你想判断一个点是否在一个 * 开放路径的范围内时, 你需要先Copy一份路径, * 并调用 -(void)closePath; 将路径封闭, 然后 * 再调用此方法来判断指定点是否是内部点. * @param point: 指定点. */- (BOOL) containsPoint:(CGPoint)point; Demo实例 属性方法简单应用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 //======================================================== //&gt;&gt;&gt;Part one : 创建UIBezierPath对象。 //======================================================== //1、通过矩形： UIBezierPath * rectPath = [UIBezierPath bezierPathWithRect:CGRectMake(0, 0, 30, 50)]; /** 判断相关： */ //ONE:是否包含。 BOOL isContain = [rectPath containsPoint:CGPointMake(25, 24)]; if (isContain) &#123; NSLog(@&quot;contain&quot;); &#125; //TWO:路径是否为空。 BOOL isEmpty = [rectPath isEmpty]; if (!isEmpty) &#123; NSLog(@&quot;not empty&quot;); &#125; /** 相关属性： */ rectPath.lineWidth = 3; rectPath.lineCapStyle = kCGLineCapSquare; //曲线终点样式，不适用于闭合路径。 rectPath.lineJoinStyle = kCGLineJoinMiter; //曲线连接样式。 rectPath.miterLimit = 2; //内外角最大距离。 rectPath.flatness = 0.6; //默认0.6，越低精度越高。 rectPath.usesEvenOddFillRule = YES; //是否适用奇偶填充规则。默认非零规则填充。 NSLog(@&quot;覆盖的矩形区域:%@&quot;,[NSValue valueWithCGRect:rectPath.bounds]);//判断覆盖的矩形区域 [[UIColor orangeColor]set]; [rectPath stroke]; //2、通过椭圆(矩形的内切椭圆) UIBezierPath * ovalPath= [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 70, 30, 50)]; [[UIColor redColor]set]; [ovalPath stroke]; //3、通过圆角矩形： UIBezierPath * cornerRectPath = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(0, 130, 30, 50) cornerRadius:3]; [[UIColor blackColor] set]; [cornerRectPath stroke]; //4、通过圆弧： UIBezierPath * arcPath = [UIBezierPath bezierPathWithArcCenter:CGPointMake(60, 200) radius:50 startAngle:M_PI_2 endAngle:M_PI clockwise:YES]; [[UIColor brownColor] set]; arcPath.lineWidth = 4; [arcPath stroke]; //5、通过path。 CGPathRef pathRef = CGPathCreateWithRect(CGRectMake(0, 280, 30, 50), nil); UIBezierPath * pathPath = [UIBezierPath bezierPathWithCGPath:pathRef]; [[UIColor redColor]set]; [pathPath stroke]; //======================================================== //&gt;&gt;&gt;Part two：构造路径： //======================================================== UIBezierPath * allocPath = [UIBezierPath bezierPath]; allocPath.lineWidth= 4; [allocPath moveToPoint:CGPointMake(50, 350)]; //追加一条直线路径：// [allocPath addLineToPoint:CGPointMake(50, 400)]; //追加一条圆弧：(当起始点到圆心的距离大于半径的时候，起始点到距离圆心半径的点上会作一条直线)// [allocPath addArcWithCenter:CGPointMake(50, 400) radius:50 startAngle:M_PI_2+M_PI endAngle:M_PI_2 clockwise:NO]; //追加一条三次贝塞尔曲线：// [allocPath addCurveToPoint:CGPointMake(50, 400) controlPoint1:CGPointMake(60, 370) controlPoint2:CGPointMake(30, 385)]; //追加一条二次贝塞尔曲线; [allocPath addQuadCurveToPoint:CGPointMake(50, 400) controlPoint:CGPointMake(30, 385)]; //关闭路径： [allocPath closePath]; //删除所有点：// [allocPath removeAllPoints]; //添加一个路径到当前路径中来。// [allocPath appendPath:pathPath]; //填充;// [allocPath fill]; //选择将以何种混合方式进行填充。//?// [allocPath fillWithBlendMode:kCGBlendModeLighten alpha:0.8]; [[UIColor orangeColor] set]; [allocPath stroke]; [[UIColor redColor]setFill]; UIRectFill(CGRectMake(100, 50, 100, 50)); CAShapeLayer属性介绍：大多属性和UIBezierPath的属性类似。 path： CGPathRef 对象，图形边线路径。 fillColor：CGColorRef对象，图形填充色，默认为黑色。 fillRule：填充规则。类似于UIBezierPath的fillMode属性。 kCAFillRuleNonZero : 非零环绕数规则。 这个规则通过从canvas上的某个点往任一方向绘制射线到无穷远，然后检查图形的线段和射线相交的点，来确定“内部区域”。从0开始计数，每次路径线段是从左到右穿过射线就加一，从右到左的就减一。通过计算交叉点，如果结果是0，则这个点在路径外边，不然，就是在里边。 [图片上传失败…(image-4ee41e-1552033143799)] kCAFillRuleEvenOdd : 奇偶原则。 通过从canvas上某个点往任一方向绘制射线到无穷远，然后计算给定图形上线段路径和该射线交叉点的数量。如果这个数是奇数，那么该点在图形内部；如果是偶数，该点在图形外部。 [图片上传失败…(image-53b934-1552033143799)] strokeColor:边线颜色。 lineDashPhase:边线样式的起始位置，即，如果lineDashPattern设置为@[2,2,3,4], lineDashPhase即为第一个长度为2的线的起始位置。 strokeStart,strokeEnd: [0，1]表示画边线的起点和终点。 lineDashPattern: NSNumber数组，依次表示单个线的长度和空白的长度。 ####DEMO 123456789101112131415161718192021// 创建一个路径对象UIBezierPath *linePath = [UIBezierPath bezierPath];// 起点[linePath moveToPoint:(CGPoint)&#123;20,20&#125;];// 其他点[linePath addLineToPoint:(CGPoint)&#123;180,160&#125;];[linePath addLineToPoint:(CGPoint)&#123;200,50&#125;];[linePath addLineToPoint:CGPointMake(250, 250)];// 设置路径画布CAShapeLayer *lineLayer = [CAShapeLayer layer];lineLayer.bounds = (CGRect)&#123;0,0,200,200&#125;;lineLayer.position = CGPointMake(100, 100);lineLayer.lineWidth = 2.0;lineLayer.strokeColor = [UIColor blueColor].CGColor; // 边线颜色lineLayer.path = linePath.CGPath;lineLayer.fillColor = nil; // 默认是black// 添加到图层上[self.layer addSublayer:lineLayer]; 更多Demo可见关于贝塞尔曲线与CAShapeLayer的学习 ####总结： UIBezierPath 在当前的绘图上下文中绘制图形了. 因为创建、 配置、 渲染路径等操作, 都是完全不同的步骤, 所以你可以在你的代码中非常容易的对UIBezierPath 对象进行复用. 你甚至可以使用同一个 UIBezierPath 对象去渲染同一个图形很多次, 你也可以再多次渲染的间隔中, 修改属性来渲染出不同样式的路径. 当你为UIBezierPath 对象配置完几何路径和绘图属性之后, 你就可以使用stroke 和 fill方法在当前的绘图上下文中进行绘制了. stroke方法将会使用当前的strokeColor 和 绘图属性来描绘曲线的轮廓. 同样的, fill 方法将会使用fillColor 来填充路径所围成的图形(使用UIColor 类方法来设置strokeColor 和 fillColor).]]></content>
      <tags>
        <tag>Core Graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Core Graphics - 基础介绍]]></title>
    <url>%2F2017%2F05%2F08%2FCore-Graphics-%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[CoreGraphics也称为Quartz 2D 是UIKit下的主要绘图系统，频繁的用于绘制自定义视图。Core Graphics是高度集成于UIView和其他UIKit部分的。Core Graphics数据结构和函数可以通过前缀CG来识别。 先简单粗暴，上五个常用实例 视图可以通过子视图、图层或实现drawRect：方法来表现内容，如果说实现了drawRect：方法，那么最好就不要混用其他方法了，如图层和子视图。自定义绘图大部分是由UIKit或者Core Graphics来实现的。 实例1、绘制文本12345CGContextRef context4 = UIGraphicsGetCurrentContext();NSString *string = @&quot;我是文本&quot;;NSDictionary *attrs = [NSDictionary dictionaryWithObjectsAndKeys:[UIFont systemFontOfSize:35], NSFontAttributeName, [UIColor orangeColor], NSForegroundColorAttributeName, nil];[string drawAtPoint:CGPointMake(30, 450) withAttributes:attrs];CGContextSaveGState(context4); 2、绘制图片12UIImage * img = [UIImage imageNamed:@&quot;bg&quot;];[img drawInRect:CGRectMake(20, 500, 50, 200)]; 3、渐变效果12345678910CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();NSArray *colors = @[(__bridge id)[UIColor colorWithRed:0.3 green:0.0 blue:0.0 alpha:0.2].CGColor, (__bridge id)[UIColor colorWithRed:0.0 green:0.0 blue:1.0 alpha:0.8].CGColor];const CGFloat locations[] = &#123;0.0, 1.0&#125;;CGGradientRef gradient = CGGradientCreateWithColors(colorSpace, (__bridge CFArrayRef)colors, locations);CGContextDrawLinearGradient(context, gradient, CGPointMake(200, 150), CGPointMake(250, 200), 0); //开始绘制//释放资源CGGradientRelease(gradient);CGColorSpaceRelease(colorSpace); 4、画矩形123456CGContextRef context3 = UIGraphicsGetCurrentContext();CGContextAddRect(context, CGRectMake(200, 150, 50, 50));[[UIColor orangeColor]setStroke];CGContextSetLineWidth(context3, 3);CGContextDrawPath(context3, kCGPathStroke);CGContextSaveGState(context3); 5、画线123456789101112131415161718192021[[UIColor redColor] setFill];[[UIColor blackColor] setStroke];CGContextRef context = UIGraphicsGetCurrentContext();CGContextSetLineWidth(context, 5.0f);CGContextSetLineJoin(context, kCGLineJoinRound);//设置连接点样式。CGContextMoveToPoint(context, 50, 100);CGContextAddLineToPoint(context, 70, 300);CGContextAddLineToPoint(context, 80, 200);CGContextClosePath(context);CGContextDrawPath(context, kCGPathFillStroke);CGContextSaveGState(context);//保存上下文状态CGContextRef context2 = UIGraphicsGetCurrentContext();[[UIColor brownColor]set];CGContextSetLineWidth(context2, 3);CGContextMoveToPoint(context2, 200, 100);CGContextAddLineToPoint(context2, 300, 100);CGContextAddLineToPoint(context2, 350, 250);CGContextStrokePath(context2);CGContextSaveGState(context2); CGContextRef Graphics Context是图形上下文,也可以理解为一块画布,我们可以在上面进行绘画操作,绘制完成后,将画布放到我们的view中显示即可,view看作是一个画框。接下来开始CGContextRef的相关方法介绍，方法较多，大家可筛选重点来看。 相关枚举值 线段端点的绘制形状： 12345typedef CF_ENUM(int32_t, CGLineJoin) &#123; kCGLineJoinMiter, // 这是默认的属性值。该方格的连接点形状如图1所示。 kCGLineJoinRound, // 稍微圆角, 该方格的连接点形状如图2所示。 kCGLineJoinBevel // 斜角,该方格的连接点形状如图3所示。&#125;; 设置方法： 1void CGContextSetLineCap(CGContextRef__nullable c, CGLineCap cap) 连接点样式： 12345typedef CF_ENUM(int32_t, CGLineJoin) &#123; kCGLineJoinMiter, // 这是默认的属性值。该方格的连接点形状如图1所示。 kCGLineJoinRound, // 稍微圆角, 该方格的连接点形状如图2所示。 kCGLineJoinBevel // 斜角,该方格的连接点形状如图3所示。&#125;; [图片上传失败…(image-b758c4-1557146885538)] 设置方法： 1void CGContextSetLineJoin(CGContextRef__nullable c, CGLineJoin join) 当把连接点风格设为meter风格时，该方法用于控制锐角箭头的长度: 1void CGContextSetMiterLimit(CGContextRef__nullable c, CGFloat limit) 绘制模式： 1234567typedef CF_ENUM (int32_t, CGPathDrawingMode) &#123; kCGPathFill,//只有填充（非零缠绕数填充），不绘制边框 如图1 kCGPathEOFill,//奇偶规则填充（多条路径交叉时，奇数交叉填充，偶交叉不填充）如图2 kCGPathStroke, // 只有边框 如图3 kCGPathFillStroke, // 既有边框又有填充 如图4 kCGPathEOFillStroke // 奇偶填充并绘制边框 如图5&#125;; 绘制的时候可以用到 1void CGContextDrawPath(CGContextRef__nullable c, CGPathDrawingMode mode) 方法-状态相关： 保存绘图状态： 1234//为了让开发者在进行坐标变换时无须计算多次坐标变换后的累加结果，Quartz 2D还提供了如下两个方法来保存、恢复绘图状态 保存CGContextRef当前的绘图状态，方便以后恢复该状态 // 需要说明的是，CGContextSaveGState()函数保存的绘图状态，不仅包括当前坐标系统的状态，也包括当前设置的填充风格、线条风格、阴影风格等各种绘图状态。但 CGContextSaveGState()函数不会保存当前绘制的图形void CGContextSaveGState(CGContextRef__nullable c) 把CGContextRef恢复到最近一次保存的状态: 1void CGContextRestoreGState(CGContextRef__nullable c) 方法-更改坐标系统： 缩放坐标系统： 12//该方法控制坐标系统水平方向上缩放 sx，垂直方向上缩放 sy。在缩放后的坐标系统上绘制图形时，所有点的 X 坐标都相当于乘以 sx 因子，所有点的 Y 坐标都相当于乘以 sy因子。void CGContextScaleCTM(CGContextRef__nullable c, CGFloat sx, CGFloat sy) 平移坐标系统: 123// 该方法相当于把原来位于 (0, 0) 位置的坐标原点平移到 (tx, ty)点。在平移后的坐标系统上绘制图形时，所有坐标点的 X坐标都相当于增加了 tx，所有点的 Y坐标都相当于增加了 ty。void CGContextTranslateCTM(CGContextRef__nullable c, CGFloat tx, CGFloat ty) 旋转坐标系统: 12 //该方法控制坐标系统旋转 angle 弧度。在缩放后的坐标系统上绘制图形时，所有坐标点的 X、Y坐标都相当于旋转了 angle弧度之后的坐标。void CGContextRotateCTM(CGContextRef__nullable c, CGFloat angle) 矩阵变换 通过矩阵设置变换： 123 //使用 transform变换矩阵对 CGContextRef的坐标系统执行变换，通过使用坐标矩阵可以对坐标系统执行任意变换。void CGContextConcatCTM(CGContextRef__nullable c, CGAffineTransform transform) 拿到变换中的矩阵： 1CGAffineTransform CGContextGetCTM(CGContextRef__nullable c) 方法-设置： 设置绘制直线、边框时的线条宽度： 1void CGContextSetLineWidth(CGContextRef__nullable c, CGFloat width) 设置虚线模式： 123 // Linedash pattern(虚线模式)允许我们沿着描边绘制虚线。我们通过在CGContextSetLineDash结构体中指定虚线数组和虚线相位来控制虚线的大小及位置。其中lengths属性指定了虚线段的长度，该值是在绘制片断与未绘制片断之间交替。phase属性指定虚线模式的起始点。图3-11显示了虚线模式：void CGContextSetLineDash(CGContextRef__nullable c, CGFloat phase,const CGFloat *__nullable lengths, size_t count) 设置弯曲的路径中的图形上下文的准确性 1void CGContextSetFlatness(CGContextRef__nullable c, CGFloat flatness) 设置全局透明度 1void CGContextSetAlpha(CGContextRef__nullable c, CGFloat alpha) 设置CGContextRef的叠加模式。Quartz 2D支持多种叠加模式： 1void CGContextSetBlendMode(CGContextRef __nullable c, CGBlendMode mode) 方法-路径变换： 开创新路径： 1void CGContextBeginPath(CGContextRef__nullable c) 开始一个新的子路径起点： 12void CGContextMoveToPoint(CGContextRef__nullable c, CGFloat x, CGFloat y) 添加一条直线段： 12void CGContextAddLineToPoint(CGContextRef__nullable c, CGFloat x, CGFloat y) 添加多条直线路径： 12void CGContextAddLines(CGContextRef__nullable c, const CGPoint * __nullable points, size_t count) 添加一个三次bezier曲线： 12345678910/** * 从当前添加一个三次Bezier曲线 * @param cp1x 控制点1 x坐标 * @param cp1y 控制点1 y坐标 * @param cp2x 控制点2 x坐标 * @param cp2y 控制点2 y坐标 * @param x 直线的终点 x坐标 * @param y 直线的终点 y坐标 */void CGContextAddCurveToPoint(CGContextRef__nullable c, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y) 添加一个二次bezier曲线： 12345678/** * 从当前添加一个二次Bezier曲线 * @param cpx 控制点 x坐标 * @param cpy 控制点 y坐标 * @param x 直线的终点 x坐标 * @param y 直线的终点 y坐标 */void CGContextAddQuadCurveToPoint(CGContextRef__nullable c, CGFloat cpx, CGFloat cpy,CGFloat x,CGFloat y) 关闭子路径，并连接当前点和起点。 1void CGContextClosePath(CGContextRef__nullable c) 添加矩形路径: 1void CGContextAddRect(CGContextRef__nullable c, CGRect rect) 添加多个矩形路径： 12void CGContextAddRects(CGContextRef__nullable c, const CGRect * __nullable rects, size_t count) 添加一个椭圆： 1void CGContextAddEllipseInRect(CGContextRef__nullable c, CGRect rect) 添加一个弧形对象： 12345678910/** * 添加弧形对象 * @param x 中心点x坐标 * @param y 中心点y坐标 * @param radius 半径 * @param startAngle 起始弧度 * @param endAngle 终止弧度 * @param clockwise 是否逆时针绘制，0则顺时针绘制 */void CGContextAddArc(CGContextRef__nullable c, CGFloat x,CGFloat y,CGFloat radius,CGFloat startAngle,CGFloat endAngle,int clockwise) 使用一个序列的三次贝塞尔曲线创建一个弧： 原理:首先画两条线，这两条线分别是 current point to (x1,y1)和(x1,y1) to (x2,y2).这样就是出现一个以(x1,y1)为顶点的两条射线，然后定义半径长度，这个半径是垂直于两条射线的，这样就能决定一个圆了，如果当前点和第一个切点的弧(起点)是不平等的,那么会添加一条直线段从当前指向第一个切点。弧的终点成为新的当前点的路径。 12void CGContextAddArcToPoint(CGContextRef__nullable c, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius) 添加路径到上下文： 1void CGContextAddPath(CGContextRef__nullable c, CGPathRef__nullable path) 使用绘制当前路径时覆盖的区域作为当前CGContextRef中的新路径 举例来说，假如当前CGContextRef包含一个圆形路径且线宽为10，调用该方法后，当前CGContextRef将包含一个环宽为10的环形路径 填充该路径包围的区域: 1void CGContextFillPath(CGContextRef__nullable c) 使用奇偶规则来填充该路径包围的区域: 奇偶规则指：如果某个点被路径包围了奇数次，系统绘制该点；如果被路径包围了偶数次，系统不绘制 1void CGContextEOFillPath(CGContextRef__nullable c) 使用当前 CGContextRef设置的线宽绘制路径 1void CGContextStrokePath(CGContextRef__nullable c) 填充rect代表的矩形 1void CGContextFillRect(CGContextRef__nullable c, CGRect rect) 填充多个矩形： 12void CGContextFillRects(CGContextRef__nullable c, const CGRect * __nullable rects, size_t count) 使用当前 CGContextRef设置的线宽绘制矩形框 1void CGContextStrokeRect(CGContextRef__nullable c, CGRect rect) 使用指定线宽绘制矩形框: 12void CGContextStrokeRectWithWidth(CGContextRef__nullable c, CGRect rect, CGFloat width) 擦除指定矩形区域上绘制的图形: 1void CGContextClearRect(CGContextRef__nullable c, CGRect rect) 填充rect矩形的内切椭圆区域: 1void CGContextFillEllipseInRect(CGContextRef__nullable c,CGRect rect) 使用当前 CGContextRef设置的线宽绘制rect矩形的内切椭圆: 1void CGContextStrokeEllipseInRect(CGContextRef__nullable c, CGRect rect) 绘制多个线段。 该方法需要传入2N个CGPoint组成的数组，其中1、2个点组成第一条线段，3、4个点组成第2条线段，以此类推. 1void CGContextStrokeLineSegments(CGContextRef__nullable c,const CGPoint * __nullable points, size_t count) 修改当前剪切路径： 12345/* 修改当前剪贴路径，使用非零绕数规则。 */void CGContextClip(CGContextRef__nullable c)/* 修改当前剪贴路径，使用奇偶规则。 */void CGContextEOClip(CGContextRef__nullable c) 剪切遮罩处理(针对图片) 1void CGContextClipToMask(CGContextRef__nullable c, CGRect rect, CGImageRef__nullable mask) 剪切矩形外的部分. 12345/* 剪切指定矩形区域外的部分. */void CGContextClipToRect(CGContextRef__nullable c, CGRect rect)/* 剪切指定多个矩形区域外的部分 */void CGContextClipToRects(CGContextRef__nullable c,const CGRect * rects, size_t count) 使用指定颜色来设置该CGContextRef的填充颜色 1void CGContextSetFillColorWithColor(CGContextRef__nullable c,CGColorRef __nullable color) 使用指定颜色来设置该CGContextRef的线条颜色 1void CGContextSetStrokeColorWithColor(CGContextRef__nullable c,CGColorRef __nullable color) 方法-读取 返回一个非空的路径中的当前点： 1CGPoint CGContextGetPathCurrentPoint(CGContextRef__nullable c) 返回当前路径的最小矩形： 1CGRect CGContextGetPathBoundingBox(CGContextRef__nullable c) 返回拷贝后的一个path： 1CGPathRef __nullableCGContextCopyPath(CGContextRef__nullable c) 获取到了需要绘制的图形上下文的位置与大小 1CGRect CGContextGetClipBoundingBox(CGContextRef__nullable c) 方法-判断 表示目前的路径是否包含任何的子路径 1bool CGContextIsPathEmpty(CGContextRef__nullable c) 检查当前路径是否包含指定的点： 12bool CGContextPathContainsPoint(CGContextRef__nullable c, CGPoint point, CGPathDrawingMode mode) 其它方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330/** Color space functions. **//* 颜色空间填充 */void CGContextSetFillColorSpace(CGContextRef__nullable c, CGColorSpaceRef__nullable space)/* 设置线框颜色空间 */void CGContextSetStrokeColorSpace(CGContextRef__nullable c, CGColorSpaceRef __nullable space)/** Color functions. **//* 设置填充颜色空间 CGFloat redColor[4] = &#123;1.0,0,0,1.0&#125;;*/void CGContextSetFillColor(CGContextRef__nullable c,const CGFloat *__nullable components(redColor))/* 设置画笔颜色 CGFloat redColor[4] = &#123;1.0,0,0,1.0&#125;;*/void CGContextSetStrokeColor(CGContextRef__nullable c,const CGFloat *__nullable components(redColor))/** Pattern functions. **//* 设置该CGContextRef使用位图填充*/void CGContextSetFillPattern(CGContextRef__nullable c, CGPatternRef__nullable pattern,const CGFloat * __nullable components)/* 设置该CGContextRef使用位图绘制线条、边框*/void CGContextSetStrokePattern(CGContextRef__nullable c, CGPatternRef__nullable pattern,const CGFloat * __nullable components)/* 设置该CGContextRef采用位图填充的相位*/void CGContextSetPatternPhase(CGContextRef__nullable c, CGSize phase)/** Color convenience functions. **//* 使用灰色来设置该CGContextRef的填充颜色*/void CGContextSetGrayFillColor(CGContextRef__nullable c, CGFloat gray, CGFloat alpha)/* 使用灰色来设置该CGContextRef的线条颜色*/void CGContextSetGrayStrokeColor(CGContextRef__nullable c, CGFloat gray, CGFloat alpha)/* 使用RGB颜色模式来设置该CGContextRef的填充颜色*/void CGContextSetRGBFillColor(CGContextRef__nullable c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)/* 设置画笔颜色 */void CGContextSetRGBStrokeColor(CGContextRef__nullable c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)/* 使用CMYK颜色模式来设置该CGContextRef的填充颜色*/void CGContextSetCMYKFillColor(CGContextRef__nullable c, CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha)/* 使用CMYK颜色模式来设置该CGContextRef的线条颜色*/void CGContextSetCMYKStrokeColor(CGContextRef__nullable c, CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha)/** Rendering intent. **//* 在当前图形状态设置渲染意向 */void CGContextSetRenderingIntent(CGContextRef__nullable c, CGColorRenderingIntent intent)/** Image functions. **//* 绘制图像到图形上下文中 */void CGContextDrawImage(CGContextRef__nullable c, CGRect rect, CGImageRef __nullable image)/* 重复绘制的图像，扩展到提供的矩形，填补当前剪辑区域。 */void CGContextDrawTiledImage(CGContextRef__nullable c, CGRect rect, CGImageRef __nullable image)/* 获取当前CGContextRef在放大图片时的插值质量*/CGInterpolationQuality CGContextGetInterpolationQuality(CGContextRef__nullable c)/* 设置图形上下文的插值质量水平。*/void CGContextSetInterpolationQuality(CGContextRef__nullable c, CGInterpolationQuality quality)/** Shadow support. **//* 设置阴影在X、Y方向上的偏移，以及模糊度和阴影的颜色*/void CGContextSetShadowWithColor(CGContextRef__nullable c, CGSize offset, CGFloat blur, CGColorRef __nullable color)/* 设置阴影在X、Y方向上的偏移，以及模糊度（blur值越大，阴影越模糊）。该函数没有设置阴影颜色，默认使用1/3透明的黑色（即RGBA&#123;0, 0, 0, 1.0/3.0&#125;）作为阴影颜色*/void CGContextSetShadow(CGContextRef__nullable c, CGSize offset, CGFloat blur)/** Gradient and shading functions. **//* 绘制一个渐变填充定义的出发点和落脚点沿线变化。*/void CGContextDrawLinearGradient(CGContextRef__nullable c, CGGradientRef __nullable gradient, CGPoint startPoint, CGPoint endPoint, CGGradientDrawingOptions options)/* 绘制一个沿着由所提供的开始和结束的圆限定的区域变化的渐变填充。 */void CGContextDrawRadialGradient(CGContextRef__nullable c, CGGradientRef __nullable gradient, CGPoint startCenter, CGFloat startRadius, CGPoint endCenter, CGFloat endRadius, CGGradientDrawingOptions options)/* 使用指定的阴影的背景，填充剪切路径。 */void CGContextDrawShading(CGContextRef __nullable c, __nullable CGShadingRef shading)/** Text functions. **//* 设置当前字符间距. */void CGContextSetCharacterSpacing(CGContextRef__nullable c, CGFloat spacing)/* 设置要绘制文本的位置。 */void CGContextSetTextPosition(CGContextRef__nullable c, CGFloat x, CGFloat y)/* 返回在绘制文本的位置。 */CGPoint CGContextGetTextPosition(CGContextRef __nullable c)/* 设置当前文本矩阵。 */void CGContextSetTextMatrix(CGContextRef__nullable c, CGAffineTransform t)/* 返回当前文本矩阵。 */CGAffineTransform CGContextGetTextMatrix(CGContextRef__nullable c)/* 设置当前文本的绘图模式。 */void CGContextSetTextDrawingMode(CGContextRef__nullable c, CGTextDrawingMode mode)/* 设置上下文的字体 */void CGContextSetFont(CGContextRef__nullable c, CGFontRef __nullable font)/* 设置上下文的字体大小。 */void CGContextSetFontSize(CGContextRef__nullable c, CGFloat size)/* 在所提供的位置绘制字形。 */void CGContextShowGlyphsAtPositions(CGContextRef__nullable c, const CGGlyph * __nullable glyphs, const CGPoint * __nullable Lpositions, size_t count)/** PDF functions. **//* 绘制一个PDF页面到当前的用户空间。 */void CGContextDrawPDFPage(CGContextRef__nullable c, CGPDFPageRef __nullable page)/** Output page functions. **//* 基于页面的图形上下文中开始了新的一页。 */void CGContextBeginPage(CGContextRef__nullable c,const CGRect *__nullable mediaBox)/* 在基于页面的图形上下文结束当前的页面。 */void CGContextEndPage(CGContextRef__nullable c)/** Context functions. **//* 图形上下文的引用计数+1 */CGContextRef __nullableCGContextRetain(CGContextRef__nullable c)/* 图形上下文的引用计数-1. */void CGContextRelease(CGContextRef__nullable c)/* 强制所有挂起的绘图操作在一个窗口上下文中立即被渲染到目标设备 */void CGContextFlush(CGContextRef__nullable c)/* 将一个窗口的图像上下文内容更新，即所有的绘图操作都会在下次同步到窗口上. */void CGContextSynchronize(CGContextRef__nullable c)/** Antialiasing functions. **//* 设置该CGContextRef是否应该抗锯齿（即光滑图形曲线边缘）*/void CGContextSetShouldAntialias(CGContextRef__nullable c, bool shouldAntialias)/* 设置该CGContextRef是否允许抗锯齿*/void CGContextSetAllowsAntialiasing(CGContextRef__nullable c, bool allowsAntialiasing)/** Font display functions. **//* 设置该CGContextRef是否允许光滑字体*/void CGContextSetShouldSmoothFonts(CGContextRef__nullable c, bool shouldSmoothFonts)/* 设置该CGContextRef是否允许光滑字体*/void CGContextSetAllowsFontSmoothing(CGContextRef__nullable c, bool allowsFontSmoothing)// Enables or disables subpixel positioning in a graphics context.void CGContextSetShouldSubpixelPositionFonts( CGContextRef __nullable c, bool shouldSubpixelPositionFonts)// Sets whether or not to allow subpixel positioning for a graphics contextvoid CGContextSetAllowsFontSubpixelPositioning( CGContextRef __nullable c, bool allowsFontSubpixelPositioning)// Enables or disables subpixel quantization in a graphics context.void CGContextSetShouldSubpixelQuantizeFonts( CGContextRef __nullable c, bool shouldSubpixelQuantizeFonts)// Sets whether or not to allow subpixel quantization for a graphics contextvoid CGContextSetAllowsFontSubpixelQuantization( CGContextRef __nullable c, bool allowsFontSubpixelQuantization)/** Transparency layer support. **//* 开始一个透明层。 直到相应的调用CGContextEndTransparencyLayer，在指定范围内的所有后续绘制操作组合到一个完全透明的背景（它被视为一个单独的目标缓冲区从上下文）。在透明层中绘制需要三步： 1. 调用函数 CGContextBeginTransparencyLayer 2. 在透明层中绘制需要组合的对象 3. 调用函数 CGContextEndTransparencyLayer*/void CGContextBeginTransparencyLayer(CGContextRef__nullable c, CFDictionaryRef __nullable auxiliaryInfo)/* 开始透明度层，它的边界是指定的矩形，其内容是有界的。 */void CGContextBeginTransparencyLayerWithRect( CGContextRef __nullable c, CGRect rect, CFDictionaryRef__nullable auxInfo)/* 结束一个透明层。 */void CGContextEndTransparencyLayer(CGContextRef__nullable c)/** User space to device space tranformations. **//* 获取Quartz转换用户空间和设备空间的仿射变换 */CGAffineTransform CGContextGetUserSpaceToDeviceSpaceTransform(CGContextRef__nullable c)/*———— 点 ————*//* 将一个CGPoint数据结构从一个空间变换到另一个空间(DeviceSpace). */CGPoint CGContextConvertPointToDeviceSpace(CGContextRef__nullable c, CGPoint point)/* 将一个CGPoint数据结构从一个空间变换到另一个空间(UserSpace). */CGPoint CGContextConvertPointToUserSpace(CGContextRef__nullable c, CGPoint point)/*———— 大小 ————*//* 将一个CGSize数据结构从一个空间变换到另一个空间(DeviceSpace). */CGSize CGContextConvertSizeToDeviceSpace(CGContextRef__nullable c, CGSize size)/* 将一个CGSize数据结构从一个空间变换到另一个空间(UserSpace). */CGSize CGContextConvertSizeToUserSpace(CGContextRef__nullable c, CGSize size)/*———— 矩形 ————*//* 将一个CGPoint数据结构从一个空间变换到另一个空间(DeviceSpace)。 */CGRect CGContextConvertRectToDeviceSpace(CGContextRef__nullable c, CGRect rect)/* 将一个CGPoint数据结构从一个空间变换到另一个空间(UserSpace)。 */CGRect CGContextConvertRectToUserSpace(CGContextRef__nullable c, CGRect rect)/** Deprecated functions. **/DEPRECATED…/* 设置在一个图形上下文的字体和字体大小 */void CGContextSelectFont(CGContextRef__nullable c, const char *__nullable name, CGFloat size, CGTextEncoding textEncoding)/* 在当前文本位置，由目前的文本矩阵指定的点显示一个字符数组。 */void CGContextShowText(CGContextRef__nullable c, const char *__nullable string, size_t length)/* 在指定的位置显示一个字符串。 */void CGContextShowTextAtPoint(CGContextRef__nullable c, CGFloat x, CGFloat y, const char * __nullable string, size_t length)/* 在当前文本位置显示一个数组的字形。 */void CGContextShowGlyphs(CGContextRef__nullable c, const CGGlyph * __nullable g, size_t count)/* 在指定的位置显示一个数组的字形。 */void CGContextShowGlyphsAtPoint(CGContextRef__nullable c, CGFloat x, CGFloat y, const CGGlyph * __nullable glyphs, size_t count)/* 绘制具有不同的偏移量的一个数组字形。 */void CGContextShowGlyphsWithAdvances(CGContextRef__nullable c, const CGGlyph * __nullable glyphs, const CGSize * __nullable advances, size_t count)/* DEPRECATED; use the CGPDFPage API instead. */void CGContextDrawPDFDocument(CGContextRef__nullable c, CGRect rect, CGPDFDocumentRef__nullable document,int page)DEPRECATED…]]></content>
      <tags>
        <tag>Core Graphics</tag>
      </tags>
  </entry>
</search>
