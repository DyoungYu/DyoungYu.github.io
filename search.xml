<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[通过Runtime源码，分析OC消息发送及处理]]></title>
    <url>%2F2019%2F03%2F04%2Fruntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%2F</url>
    <content type="text"><![CDATA[#前言 日常开发中我们得知，当我们通过对象调用一个方法时，本质是通过objc_msgSend给对象发送消息。这点我们可以通过clang编译后的代码得知。1MyPerson *p = [MyPerson new]; 通过xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc OC源文件 -o 输出的CPP文件编译得： 1MyPerson *p = ((MyPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;MyPerson&quot;), sel_registerName(&quot;new&quot;)); 可知接收消息的对象是：(id)objc_getClass(&quot;MyPerson&quot;)。接收的消息编号：sel_registerName(&quot;new&quot;) == @selector(new)。通过分析objc4-750源码，以objc_msgSend为入口，接下来我们开始分析整个消息发送及处理流程。 整个流程分为快速和慢速两种方式。快速：通过汇编，在缓存(cache)的imp哈希表中寻找。这样的好处是C、C++等语言不能通过写一个函数，来直接保留未知的参数，跳转到任意的指针。而汇编通过调用寄存器，可很好的实现这一点。慢速： 通过C、C++在方法列表中寻找。找到了会往chche中存。以上方法找不到，就会通过特殊的动态处理。 #0x01 汇编缓存查找 在objc4-750源码中搜索_objc_msgSend,点击查看在arm64架构中的ENTRY _objc_msgSend。代码和注释如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556ENTRY _objc_msgSend UNWIND _objc_msgSend, NoFrame//tagged pointer：特殊的数据类型，更为轻量。 cmp p0, #0 // nil check and tagged pointer check#if SUPPORT_TAGGED_POINTERS b.le LNilOrTagged // (MSB tagged pointer looks negative)#else b.eq LReturnZero#endif ldr p13, [x0] // p13 = isa GetClassFromIsa_p16 p13 // p16 = class LGetIsaDone://isa处理完毕。//这里可以作为后面传参的一个参考。//！！主要函数！！//在缓存列表中找imp//这里CacheLookup有三种方式：NORMAL|GETIMP|LOOKUP//1、成功：call imp //2、失败：objc_msgSend_uncached CacheLookup NORMAL // calls imp or objc_msgSend_uncached#if SUPPORT_TAGGED_POINTERSLNilOrTagged: b.eq LReturnZero // nil check // tagged adrp x10, _objc_debug_taggedpointer_classes@PAGE add x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF ubfx x11, x0, #60, #4 ldr x16, [x10, x11, LSL #3] adrp x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE add x10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF cmp x10, x16 b.ne LGetIsaDone // ext tagged adrp x10, _objc_debug_taggedpointer_ext_classes@PAGE add x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF ubfx x11, x0, #52, #8 ldr x16, [x10, x11, LSL #3] b LGetIsaDone// SUPPORT_TAGGED_POINTERS#endifLReturnZero: // x0 is already zero mov x1, #0 movi d0, #0 movi d1, #0 movi d2, #0 movi d3, #0 ret END_ENTRY _objc_msgSend 通过查看CacheLookup的宏定义代码,得知缓存中寻找的三种形式：CacheHit | CheckMiss | add//1：找到直接返回//2：找不到的话直接checkmiss//3：在其它地方找到的话通过汇编直接add进缓存中。12345678910111213141516171819202122232425.macro CacheLookup // p1 = SEL, p16 = isa ldp p10, p11, [x16, #CACHE] // p10 = buckets, p11 = occupied|mask#if !__LP64__ and w11, w11, 0xffff // p11 = mask#endif and w12, w1, w11 // x12 = _cmd &amp; mask add p12, p10, p12, LSL #(1+PTRSHIFT) // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT)) ldp p17, p9, [x12] // &#123;imp, sel&#125; = *bucket1: cmp p9, p1 // if (bucket-&gt;sel != _cmd) b.ne 2f // scan more CacheHit $0 // call or return imp 2: // not hit: p12 = not-hit bucket CheckMiss $0 // miss if bucket-&gt;sel == 0 cmp p12, p10 // wrap if bucket == buckets b.eq 3f ldp p17, p9, [x12, #-BUCKET_SIZE]! // &#123;imp, sel&#125; = *--bucket b 1b // loop3: // wrap: p12 = first bucket, w11 = mask add p12, p12, w11, UXTW #(1+PTRSHIFT) // p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT) 查看CacheHit的定义文件即可得知找到imp后可直接返回.12345678910.macro CacheHit.if $0 == NORMAL TailCallCachedImp x17, x12 // authenticate and call imp.elseif $0 == GETIMP mov p0, p17 AuthAndResignAsIMP x0, x12 // authenticate imp and re-sign as IMP ret // return IMP.elseif $0 == LOOKUP AuthAndResignAsIMP x17, x12 // authenticate imp and re-sign as IMP ret // return imp via x17 查看CheckMiss的定义文件即可得知找不到imp，便调用__objc_msgSend_uncached。123456789.macro CheckMiss // miss if bucket-&gt;sel == 0.if $0 == GETIMP cbz p9, LGetImpMiss//因为前面声明了CacheLookup NORMAL ，所以会走下面这个判断。.elseif $0 == NORMAL cbz p9, __objc_msgSend_uncached.elseif $0 == LOOKUP cbz p9, __objc_msgLookup_uncached 查看__objc_msgSend_uncached的代码中发现MethodTableLookup的调用，继续跟进，便发现了__class_lookupMethodAndLoadCache3的调用。12345.macro MethodTableLookup // receiver and selector already in x0 and x1 mov x2, x16 bl __class_lookupMethodAndLoadCache3//这里跳转到C++中。 #0x02 分析C++代码继上：1234567IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)&#123;//第一个YES,接上文，已经完成了isa的初始化，所以为YES.//第一个NO，接上文，通过汇编没有在cache中完成查找，所以为NO。 return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/);&#125; lookUpImpOrForward:是寻找imp的关键函数。runtime中涉及imp的获取底层都会走这个方法。比如class_getMethodImplementation、class_getInstanceMethod、class_getInstanceMethod也是通过lookUpImpOrNil,最后底层走这个方法的。 在下面的方法中大致操作为：1、首先检测缓存，如果cache有的话直接就在缓存中查找返回imp.2、如果类没被创建，便进行实例化操作。3、第一次调用类的时候，执行初始化。4、为了防止并发，再次从缓存中查找。5、遍历当前类的父类，在父类中缓存的imp中查找6、在父类的方法列表中，获取method_t对象。如果找到则缓存查找到的IMP7、如果都没有找到，就尝试动态方法解析和消息转发。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = nil; bool triedResolver = NO; runtimeLock.assertUnlocked(); // 如果cache是YES，则从缓存中查找IMP。 if (cache) &#123; // 通过cache_getImp函数查找IMP，查找到则返回IMP并结束调用 // cache_getImp：还是通过汇编来寻找的。 imp = cache_getImp(cls, sel); if (imp) return imp; &#125; runtimeLock.read(); // 判断类是否已经被创建，如果没有被创建，则将类实例化 if (!cls-&gt;isRealized()) &#123; // Drop the read-lock and acquire the write-lock. // realizeClass() checks isRealized() again to prevent // a race while the lock is down. runtimeLock.unlockRead(); runtimeLock.write(); // 对类进行实例化操作 realizeClass(cls); runtimeLock.unlockWrite(); runtimeLock.read(); &#125; // 第一次调用当前类的话，执行initialize的代码 if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; runtimeLock.unlockRead(); // 对类进行初始化，并开辟内存空间 _class_initialize (_class_getNonMetaClass(cls, inst)); runtimeLock.read(); // If sel == initialize, _class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won&apos;t happen. 2778172 &#125; //以下重点！！！ retry: runtimeLock.assertReading();//再次从缓存中获取的原因：//并发-remap(cls) imp = cache_getImp(cls, sel); if (imp) goto done; &#123; // 如果没有从cache中查找到，则从方法列表中获取Method Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) &#123; // 如果获取到对应的Method，则加入缓存并从Method获取IMP log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); imp = meth-&gt;imp; goto done; &#125; &#125; //在父类中找。 // Try superclass caches and method lists. &#123; unsigned attempts = unreasonableClassCount(); // 循环遍历父类。获取这个类的缓存IMP 或 方法列表的IMP for (Class curClass = cls-&gt;superclass; curClass != nil; curClass = curClass-&gt;superclass) &#123; // Halt if there is a cycle in the superclass chain. if (--attempts == 0) &#123; //内存溢出 _objc_fatal(&quot;Memory corruption in class list.&quot;); &#125; // Superclass cache. // 获取父类缓存的IMP imp = cache_getImp(curClass, sel); if (imp) &#123; if (imp != (IMP)_objc_msgForward_impcache) &#123; // Found the method in a superclass. Cache it in this class. // 如果发现父类的方法，并且不再缓存中，在下面的函数中缓存方法 log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; &#125; else &#123; // Found a forward:: entry in a superclass. // Stop searching, but don&apos;t cache yet; call method // resolver for this class first. break; &#125; &#125; // Superclass method list. // 在父类的方法列表中，获取method_t对象。如果找到则缓存查找到的IMP Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; goto done; &#125; &#125; &#125; // No implementation found. Try method resolver once. // 如果没有找到，则尝试动态方法解析 if (resolver &amp;&amp; !triedResolver) &#123; runtimeLock.unlockRead(); //解析。 _class_resolveMethod(cls, sel, inst); runtimeLock.read(); // Don&apos;t cache the result; we don&apos;t hold the lock so it may have // changed already. Re-do the search from scratch instead. //动态解析只能解析一次。 triedResolver = YES; goto retry; &#125; // No implementation found, and method resolver didn&apos;t help. // Use forwarding. // 如果没有IMP被发现，并且动态方法解析也没有处理，则进入消息转发阶段。只有汇编调用，没有源码实现。 imp = (IMP)_objc_msgForward_impcache; cache_fill(cls, sel, imp, inst); done: runtimeLock.unlockRead(); return imp;&#125; #0x03 动态方法解析123456789101112// 如果没有找到，则尝试动态方法解析 if (resolver &amp;&amp; !triedResolver) &#123; runtimeLock.unlockRead(); //解析。 _class_resolveMethod(cls, sel, inst); runtimeLock.read(); // Don&apos;t cache the result; we don&apos;t hold the lock so it may have // changed already. Re-do the search from scratch instead. //动态解析只能解析一次。 triedResolver = YES; goto retry; &#125; _class_resolveMethod:123456789101112131415161718void _class_resolveMethod(Class cls, SEL sel, id inst)&#123; if (! cls-&gt;isMetaClass()) &#123;//解析实例方法。 // try [cls resolveInstanceMethod:sel] // _class_resolveInstanceMethod：接收消息的是类对象。 _class_resolveInstanceMethod(cls, sel, inst); &#125; else &#123;//解析类方法。 // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] _class_resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; _class_resolveInstanceMethod(cls, sel, inst); &#125; &#125;&#125; 在_class_resolveClassMethod的实现中有如下代码，表示了消息的发送。可知消息的接受者_class_getNonMetaClass(cls, inst)。123BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(_class_getNonMetaClass(cls, inst), SEL_resolveClassMethod, sel); 进入class_getNonMetaClass的实现中,得知返回的依旧是类对象,这样是方便能够在同一个类中处理，方便管理，而避免了去虚拟的元类中进行改动。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static Class getNonMetaClass(Class metacls, id inst)&#123; static int total, named, secondary, sharedcache; runtimeLock.assertLocked(); realizeClass(metacls); total++; // metacls 元类 // metacls 类对象 //判断是否是NSObject if (!metacls-&gt;isMetaClass()) return metacls; // metacls really is a metaclass // special case for root metaclass // where inst == inst-&gt;ISA() == metacls is possible // 判断是否是根元类。 if (metacls-&gt;ISA() == metacls) &#123; Class cls = metacls-&gt;superclass; assert(cls-&gt;isRealized()); assert(!cls-&gt;isMetaClass()); assert(cls-&gt;ISA() == metacls); if (cls-&gt;ISA() == metacls) return cls; &#125; // 类对象 if (inst) &#123; Class cls = (Class)inst; realizeClass(cls); // cls may be a subclass - find the real class for metacls // 元类 != 元类 while (cls &amp;&amp; cls-&gt;ISA() != metacls) &#123; cls = cls-&gt;superclass; realizeClass(cls); &#125; // 最终返回的还是类对象 if (cls) &#123; assert(!cls-&gt;isMetaClass()); assert(cls-&gt;ISA() == metacls); return cls; &#125;#if DEBUG _objc_fatal(&quot;cls is not an instance of metacls&quot;);#else // release build: be forgiving and fall through to slow lookups#endif &#125; 在动态方法解析的过程中，都会调用lookUpImpOrNil来递归查找动态解析方法的imp，而不会发生死递归的原因是在NSObject中实现了动态方法解析，所以最终会找到它。同时我们通过重写NSObject中的+ (BOOL)resolveInstanceMethod:(SEL)sel，在这个方法中通过给没有实现的sel添加imp方法避免崩溃，同时也可以将crash传给后台做崩溃统计等工作。 #0x04 消息转发以下的_objc_msgForward_impcache因为苹果闭源是无法看到实现的，我们可以通过定义一个instrumentObjcMessageSends,或者通过反编译函数实现的可执行文件来查看其流程。这里简单介绍一下第二种。12imp = (IMP)_objc_msgForward_impcache;cache_fill(cls, sel, imp, inst); 通过实现动态方法解析，未实现转发而崩溃的堆栈信息可以看出_objc_msgForward_impcache具体是在CoreFoundation.framework中实现。如图：CoreFoundation.framework的本地地址：1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation 通过hopper或者ida打开，搜索_CFInitialize，再依次进入_forwarding_prep_0_，__forwarding__。通过查看伪代码，会有以下发现：1234567891011121314151617181920212223242526272829var_50 = rbx; if (class_respondsToSelector(object_getClass(r12), @selector(_forwardStackInvocation:)) != 0x0) &#123; if (*____forwarding___.onceToken != 0xffffffffffffffff) &#123; dispatch_once(____forwarding___.onceToken, ^ &#123; /* block implemented at ______forwarding____block_invoke */ &#125;); &#125; r13 = [NSInvocation requiredStackSizeForSignature:r14]; rdx = *____forwarding___.invClassSize; r12 = rsp - (rdx + 0xf &amp; 0xfffffffffffffff0); memset(r12, 0x0, rdx); objc_constructInstance(*____forwarding___.invClass, r12); var_40 = r13; [r12 _initWithMethodSignature:r14 frame:var_48 buffer:r12 - (r13 + 0xf &amp; 0xfffffffffffffff0) size:r13]; [var_38 _forwardStackInvocation:r12]; r15 = 0x1; &#125; else &#123; rbx = @selector(forwardInvocation:); if (class_respondsToSelector(object_getClass(r12), rbx) != 0x0) &#123; rdi = r12; r12 = [NSInvocation _invocationWithMethodSignature:r14 frame:var_48]; _objc_msgSend(rdi, rbx); &#125; else &#123; r12 = 0x0; _CFLog(0x4, @&quot;*** NSForwarding: warning: object %p of class &apos;%s&apos; does not implement forwardInvocation: -- dropping message&quot;, 0x0, object_getClassName(0x0), r8, r9, stack[2037]); &#125; var_40 = 0x0; r15 = 0x0; &#125; 如下，代码实现消息转发。123456789101112131415161718192021// 只有汇编调用 没有源码实现+ (id)forwardingTargetForSelector:(SEL)aSelector&#123; return [super forwardingTargetForSelector:aSelector];&#125;+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; if (aSelector == @selector(walk)) &#123; return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;]; &#125; return [super methodSignatureForSelector:aSelector];&#125;+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123; //在此切面编程 NSString *sto = @&quot;这是参数&quot;; anInvocation.target = [LGStudent class]; [anInvocation setArgument:&amp;sto atIndex:2]; NSLog(@&quot;%@&quot;,anInvocation.methodSignature); anInvocation.selector = @selector(run:); [anInvocation invoke];&#125; 如果没有实现消息转发，我们再根据源码追踪一下走位。进入消息转发的汇编部分。如下：12345678910111213141516171819202122232425262728293031323334353637STATIC_ENTRY __objc_msgForward_impcache// No stret specialization.b __objc_msgForwardEND_ENTRY __objc_msgForward_impcacheENTRY __objc_msgForwardadrp x17, __objc_forward_handler@PAGEldr p17, [x17, __objc_forward_handler@PAGEOFF]TailCallFunctionPointer x17END_ENTRY __objc_msgForwardENTRY _objc_msgSend_noargb _objc_msgSendEND_ENTRY _objc_msgSend_noargENTRY _objc_msgSend_debugb _objc_msgSendEND_ENTRY _objc_msgSend_debugENTRY _objc_msgSendSuper2_debugb _objc_msgSendSuper2END_ENTRY _objc_msgSendSuper2_debugENTRY _method_invoke// x1 is method triplet instead of SELadd p16, p1, #METHOD_IMPldr p17, [x16]ldr p1, [x1, #METHOD_NAME]TailCallMethodListImp x17, x16END_ENTRY _method_invoke 查看__objc_forward_handler回调1void *_objc_forward_handler = (void*)objc_defaultForwardHandler; 如下可以见到我们常见的崩溃信息打印的源头了。12345678910// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel)&#123; _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot; &quot;(no message forward handler is installed)&quot;, class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, object_getClassName(self), sel_getName(sel), self);&#125;]]></content>
      <categories>
        <category>iOS正向</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过dyld源码，详细分析应用加载]]></title>
    <url>%2F2019%2F01%2F14%2Fdyld%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在我们初学iOS的时候，分析一个程序的执行流程都是从main函数开始的。但是在main函数之前其实也做了不少操作，值得我们分析一下。 我们知道一个类的load的方法是先于main函数执行的，通过对load方法设置一个断点，查看调用栈可知程序在加载过程中大致所执行的一些方法。 其中可见dyld（the dynamic link editor），它是苹果的动态链接器，是苹果操作系统一个重要组成部分，在系统内核做好程序准备工作之后，交由dyld负责余下的工作。通过分析dyld的源码,我们来分析dyld做了什么。 #准备分析 1、通过分析_dyld_start的汇编实现。发现调用了dyldbootstrap::start方法。 12345678# call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue) movl 8(%rbp),%esi # param2 = argc into %esi leaq 16(%rbp),%rdx # param3 = &amp;argv[0] into %rdx movq __dyld_start_static(%rip), %r8 leaq __dyld_start(%rip), %rcx subq %r8, %rcx # param4 = slide into %rcx leaq ___dso_handle(%rip),%r8 # param5 = dyldsMachHeader leaq -8(%rbp),%r9 2、在下载好的dyld源码中搜索dyldbootstrap,在这个命名空间中寻找start方法。在这个方法中，通过slideOfMainExecutable得到因ASLR产生的偏移。通过rebaseDyld重绑定。通过__guard_setup来栈溢出保护。 123uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader, uintptr_t* startGlue) 这个start的方法的返回值是调用了一个main函数,将start的一些值作为参数传到main。 1return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue); 3、dyld也可以看做一个程序的执行，它的main函数和我们日常开发应用的main函数类似，都可以看做程序的入口。接下来我们主要便是分析main函数的实现。 123_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue) 加载过程0x01 配置环境，设置环境变量等 设置上下文 1setContext(mainExecutableMH, argc, argv, envp, apple); 配置进程是否受限 1configureProcessRestrictions(mainExecutableMH); 检查环境变量 1checkEnvironmentVariables(envp); 根据Xcode设置的环境变量，来打印程序相应参数。 1234if ( sEnv.DYLD_PRINT_OPTS ) printOptions(argv);if ( sEnv.DYLD_PRINT_ENV ) printEnvironmentVariables(envp); 会打印程序相关的目录、用户级别、插入的动态库、动态库的路径等。 12345678910111213141516171819202122opt[0] = &quot;/var/containers/Bundle/Application/731D64D1-8B04-491B-A512-4010011413E6/dyld.app/dyld&quot;CA_DEBUG_TRANSACTIONS=0TMPDIR=/private/var/mobile/Containers/Data/Application/EF8F63AD-B59A-42E7-92EE-076BC9F664D0/tmp__CF_USER_TEXT_ENCODING=0x1F5:0:0SHELL=/bin/shSQLITE_ENABLE_THREAD_ASSERTIONS=1OS_ACTIVITY_DT_MODE=YESHOME=/private/var/mobile/Containers/Data/Application/EF8F63AD-B59A-42E7-92EE-076BC9F664D0DYLD_PRINT_TO_STDERR=YESCFFIXED_USER_HOME=/private/var/mobile/Containers/Data/Application/EF8F63AD-B59A-42E7-92EE-076BC9F664D0NSUnbufferedIO=YESPATH=/usr/bin:/bin:/usr/sbin:/sbinLOGNAME=mobileXPC_SERVICE_NAME=UIKitApplication:dyoung.dyld[0x1b53][62]DYLD_INSERT_LIBRARIES=/Developer/usr/lib/libBacktraceRecording.dylib:/Developer/usr/lib/libMainThreadChecker.dylib:/Developer/Library/PrivateFrameworks/DTDDISupport.framework/libViewDebuggerSupport.dylibCLASSIC=0DYLD_PRINT_OPTS=1DYLD_PRINT_ENV=1USER=mobileXPC_FLAGS=0x1CA_ASSERT_MAIN_THREAD_TRANSACTIONS=0DYLD_LIBRARY_PATH=/usr/lib/system/introspection 通过getHostInfo获取machO头部获取当前运行架构的信息。 1static void getHostInfo(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide) 0x02 加载共享缓存库。 判断共享缓存库是否被禁用。iOS cannot run without shared region，注释说明iOS平台下是不能被禁用的。 1checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide); 通过mapSharedCache()函数加载、进入函数内部其主要实现是loadDyldCache这个函数。其中作了如下三种判断 123456789101112131415161718 if ( options.forcePrivate ) &#123; // mmap cache into this process only //只加载到当前缓存。 return mapCachePrivate(options, results); &#125; else &#123; // fast path: when cache is already mapped into shared region //快速路径，如果已经加载的话就不处理了。 bool hasError = false; if ( reuseExistingCache(options, results) ) &#123; hasError = (results-&gt;errorMessage != nullptr); &#125; else &#123; // slow path: this is first process to load cache //第一次加载的话通过它来加载。 hasError = mapCacheSystemWide(options, results); &#125; return hasError;&#125; 0x03 实例化主程序(Mach0，程序的可执行文件) 实例化过程：instantiateFromLoadedImage 123456789101112static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)&#123; // try mach-o loader //isCompatibleMachO 是检查mach-o的subtype是否是当前cpu可以支持 if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123; ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext); addImage(image);//将image添加到imagelist。所以我们在Xcode使用image list命令查看的第一个便是我们的machO return (ImageLoaderMachO*)image; &#125; throw &quot;main executable not a known format&quot;;&#125; 0x04 加载插入库 通过loadInsertedDylib方法执行插入动态库的加载。在实现中调用load方法返回imageLoader对象， imageLoader是一个抽象基类，专门用于辅助加载特定可执行文件格式的类，对于程序中需要的依赖库、插入库，会创建一个对应的image对象，对这些image进行链接，调用各image的初始化方法等等，包括对runtime的初始化。 123456// load any inserted libraries if ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123;//遍历DYLD_INSERT_LIBRARIES的环境变量。 for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib); &#125; 0x05 链接主程序，并加载系统和第三方的动态库 在 main中通过link链接主程序。 12//main 函数中link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); 内部通过imageLoader的实例对象去调用link方法。 12//image调用linkimage-&gt;link(gLinkContext, forceLazysBound, false, neverUnload, loaderRPaths, path); 递归加载我们所需要的依赖的系统库和第三方库。 1this-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath); 对依赖库进行重定位。相当于加上ASLR滑块。 1this-&gt;recursiveRebase(context); 递归绑定符号表和弱绑定。 绑定就是将这个二进制调用的外部符号进行绑定的过程。比如我们objc代码中需要使用到NSObject, 即符号OBJC_CLASS$_NSObject，但是这个符号又不在我们的二进制中，在系统库 Foundation.framework中，因此就需要binding这个操作将对应关系绑定到一起。lazyBinding就是在加载动态库的时候不会立即binding, 当第一次调用这个方法的时候再实施binding。 做到的方法也很简单： 通过dyld_stub_binder 这个符号来做。lazy binding的方法第一次会调用到dyld_stub_binder, 然后dyld_stub_binder负责找到真实的方法，并且将地址bind到桩上，下一次就不用再bind了。 1this-&gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload); 1this-&gt;weakBind(context); 插入动态库。 12345678910111213if ( sInsertedDylibCount &gt; 0 ) &#123;//有的话就开始链接加载。 for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1];//1过滤到主程序。 link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); image-&gt;setNeverUnloadRecursive(); &#125; // only INSERTED libraries can interpose // register interposing info after all inserted libraries are bound so chaining works for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1]; image-&gt;registerInterposing(gLinkContext); &#125;&#125; 0x06 初始化函数，承前启后 一、dyld流程分析-&gt; 在main函数中我们进入initializeMainExecutable-&gt;runInitializers初始化主程序-&gt;processInitializers-&gt;recursiveInitialization循环初始化-&gt;关键函数 ：notifySingle。在这个方法中调用了objc的loadImages。通过command+shift+o全局搜索寻找实现。 1static void notifySingle(dyld_image_states state, const ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo) 发现一个函数指针的调用： 1(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader()); 通过在本文件搜索sNotifyObjCInit函数指针，我们找到了赋值的地方。 123void registerObjCNotifiers(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)&#123; sNotifyObjCInit = init;//赋值函数。 全局搜索registerObjCNotifiers调用的地方 123456void _dyld_objc_notify_register(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)&#123; dyld::registerObjCNotifiers(mapped, init, unmapped);&#125; 再次全局搜索_dyld_objc_notify_register便找不到这个方法调用。于是我们通过Xcode设置符号断点来分析。如图所示，我们则能推断出这个方法的调用是在runtime中。 二、runtime流程分析分析runtime源码。可知上面的函数是在其初始化的时候进行调用的。load_images赋值到dyld中的sNotifyObjCInit指针。 1234567891011121314void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);&#125; 在load_images中，完成call_load_methods的调用。 12345678910111213141516load_images(const char *path __unused, const struct mach_header *mh)&#123; // Return without taking locks if there are no +load methods here. if (!hasLoadMethods((const headerType *)mh)) return; recursive_mutex_locker_t lock(loadMethodLock); // Discover load methods &#123; mutex_locker_t lock2(runtimeLock); prepare_load_methods((const headerType *)mh); &#125; // Call +load methods (without runtimeLock - re-entrant) call_load_methods();&#125; 在call_load_methods中，通过doWhile循环来调用call_class_loads实现每个类的load方法。 1234567891011121314151617181920212223242526272829void call_load_methods(void)&#123; static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; // 1. Repeatedly call class +loads until there aren&apos;t any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125; 三、_ _ attribute_ _((constructor)) 是GCC的扩展语法（黑魔法），由它修饰过的函数，会在main函数之前调用。原理是在ELF的.ctors段增加一条函数引用，加载器在执行main函数前，检查.ctror section，并执行里面的函数。 继续dyld分析。在imageLoader.cpp文件中，notifySingle调用之后，接着调用了doInitialization方法。 其中doModInitFunctions会调用machO文件中_mod_init_func段的函数，也就是我们在文件中所定义的全局C++构造函数。 123456789101112bool ImageLoaderMachO::doInitialization(const LinkContext&amp; context)&#123; CRSetCrashLogMessage2(this-&gt;getPath()); // mach-o has -init and static initializers doImageInit(context); doModInitFunctions(context); CRSetCrashLogMessage2(NULL); return (fHasDashInit || fHasInitializers);&#125; 通过以上分析加载流程我们可得知函数的执行顺序为： 1load -&gt; attribute((constructor)) -&gt; main -&gt; initialize 0x07 寻找应用程序主函数入口最后return,dyld的main函数结束。 12// find entry point for main executableresult = (uintptr_t)sMainExecutable-&gt;getThreadPC(); 至此，程序进入了main函数，开启了我们熟知的一切。]]></content>
      <categories>
        <category>iOS正向</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS应用脱壳(解密)的几种方式]]></title>
    <url>%2F2018%2F12%2F27%2FiOS%E5%BA%94%E7%94%A8%E8%84%B1%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[我们日常开发提交给Appstore发布的App，都经过官方保护而加密，这样可以保证机器上跑的应用是苹果审核过的，也可以管理软件授权。经过App Store加密的应用，我们无法通过Hopper等反编译静态分析，也无法Class-Dump，在逆向分析过程中需要对加密的二进制文件进行解密才可以进行静态分析，这一过程就是大家熟知的砸壳（脱壳） #一、Clutch 由KJCracks开发的一款开源砸壳工具。 #####具体操作1、使用Clutch，下载最新的release版本,可得到一个名为Clutch-2.0.4的胖二进制文件。2、通过usb登录越狱设备。3、通过命令scp -P 12345 Clutch-2.0.4 root@localhost:/usr/bin将其拷贝到越狱设备的指定目录下。可通过mv Clutch-2.0.4 Clutch对其重命名。 4、查看Clutch的可执行权限。没有的话就chmod +x Clutch添加权限即可。5、进入到越狱设备的命令行操作界面。通过Clutch命令可查看相关命令帮助信息。1234567891011Dyoung5s:~ root# pwd/var/rootDyoung5s:~ root# ClutchUsage: Clutch [OPTIONS]-b --binary-dump &lt;value&gt; Only dump binary files from specified bundleID-d --dump &lt;value&gt; Dump specified bundleID into .ipa file-i --print-installed Print installed applications --clean Clean /var/tmp/clutch directory --version Display version and exit-? --help Display this help and exit-n --no-color Print with colors disabled 6、Clutch -i 显示可砸壳的应用列表。12345678910Dyoung5s:~ root# Clutch -iInstalled apps:1: 微博国际版 &lt;com.weibo.international&gt;2: 淘宝-双十二购物，移动生活社区 &lt;com.taobao.taobao4iphone&gt;3: 今日头条极速版 &lt;com.ss.iphone.article.lite&gt;4: QQ &lt;com.tencent.mqq&gt;5: DingTalk &lt;com.laiwang.DingTalk&gt;6: 酷狗音乐-就是歌多 &lt;com.kugou.kugou1002&gt;7: 抖音短视频 &lt;com.ss.iphone.ugc.Aweme&gt;8: 爱思助手 &lt;com.diary.mood&gt; 7、Clutch -d 4选择要砸壳的应用，并进行砸壳，成功后有如下提示。将其拷贝出来即可。我们也可以通过otool -l查看其cryptid字段以验证是否砸壳成功。 #二、dumpdecrypted 通过建立一个名为dumpdecrypted.dylib的动态库，插入目标应用实现脱壳。 1、下载dumpdecrypted，并通过make命令编译生成dylib库。2、通过命令scp -P 12345 dumpdecrypted.dylib root@localhost:~/将动态库拷贝越狱设备的指定目录。 3、通过ps -A查看当前进程，并通过如下命令将其动态库插入到指定进程中。即可生成对应进程应用的MachO文件。12//后面加上的进程路径。DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/A8CC18F5-9213-482E-B145-C36EFE9ACED0/DingTalk.app/DingTalk #三、frida-ios-dump #####安装1、下载pip1sudo easy_install pip 2、通过pip下载frida_tools123sudo -H pip install frida_tools//如果报下图中的错误则更换为另外一条命令。sudo pip install six --upgrade --ignore-installed six 3、直接clonefrida-ios-dump到本地目录，进入目录可发现dump.py脚本文件。 4、修改dump.py文件中的如下信息，确保与越狱设备信息匹配。 5、在越狱设备中添加https://build.frida.re源，并且安装Frida插件. #####dump应用将脱壳应用在设备上置于运行状态。进入脚本所在文件夹，通过./dump.py 微信便可成功脱壳应用。成功后会在脚本文件所在文件夹中生成ipa包。 以上dump时的操作可写成脚本,将frida-ios-dump文件夹放置sh脚本文件的同级目录中。编写脚本，并配置环境变量即可。12//脚本内容:dump.py的路径 $1 ######遇到的一些坑：1、No module named xxx。 通过pip install --user xxx下载即可。 2、from scp import xxx，同上执行pip install --user xxx即可。 3、生成ipa，存放到脚本文件所在文件夹时没有写的权限。可直接对文件夹执行sudo chmod -R 777 文件夹路径即可。 #四、lldb手动dump #####准备1、在手机中配置好debugserver。2、通过以下命令导出需要dump应用的可执行文件到当前路径。xxxx代表应用进程路径。1scp -P 12345 root@localhost:xxxx ./ 3、查看瘦身后的可执行文件的加密信息。并记录。 1234● otool -l Aweme_arm64 | grep cry cryptoff 16384 cryptsize 52527104 cryptid 1 分析：cryptoff：指加密文件的头所对应的偏移。这个数字之前代表着可执行文件的header。cryptsize: 加密的数据长度，我们需要把这段时间拷贝出来。 #####实操1、开启debugserver服务，依附到我们想要dump应用的进程中。1debugserver *:9393 -a Aweme 2、电脑进入lldb调试环境，连接到对应的debugserver端口。1process connect [connect://localhost:9393](connect://localhost:9393) 3、通过image list指令拿到可执行文件的头地址，加上之前的cryptoff得到需要拷贝数据的起始地址。 4、按字节读取内存中的可执行文件，并拷贝到电脑。（耗时动作）12345//--force:按字节读取。//0x00000001000c4000+16384：需要拷贝内容的起始地址。//52527104：需要拷贝内容的大小。//./decrypted.bin ： 在当前目录下生成一个名为decrypted.bin的二进制包。memory read --force --outfile ./decrypted.bin --binary --count 52527104 0x00000001000c4000+16384 5、将二进制文件包替换之前拷贝出来的可执行文件中的对应部分，得到一个新的可执行文件。1234//dd：用指定大小的文件写到另一个文件当中。//bs：一个一个字节写入//conv：指定转换文件的方式。dd seek=16384 bs=1 conv=notrunc if=./decrypted.bin of=./Aweme_arm64 6、通过otool -l查看新的可执行文件，得知cryptid仍为1,这里是因为我们并没有对header文件作修改，所以字段的值仍保持之前加密的键值。但是可执行文件的内容却被我们解密了的。可以通过class-dump验证。 7、通过Mach0View 修改cryptid的值为0。如果不修改class-dump会不成功。因为这个工具首先会拿到header获取cryptid的值，如果是已加密的话就会放弃后面的dump工作了。 8、通过class-dump -H Aweme_arm64 -o ./AwemeHeaders能导出应用的头文件，便可证明lldb手动脱壳成功。 #补充 #####frida_tools的一些使用1、配置端口映射。通过frida-ps列出当前应用进程。通过usb连接好手机后，通过frida-ps -U列出usb设备的应用进程。2、通过frida -U 微信附加进程到微信。3、执行ObjC可拿到附加进程应用的所有Object-C对象。 #####插入自定义动态库到指定应用 通过这样的操作，进程没有被污染，在以后的每次执行时候不会执行我们所插入的动态库的方法。这里只相当于一次性插入。上文的dumpdecrypted便是用到了这样的原理。 1、使用Xcode生成framework文件。通过以下命令拷贝到越狱设备中。1scp -r -P 12345 DyInsert.framework/ root@localhost:~/ 2、通过以下命令将动态库插入到指定进程即可。1DYLD_INSERT_LIBRARIES=DyInsert.framework/DyInsert /var/mobile/Containers/Bundle/Application/4560ADA4-9AE4-4E9D-BE84-ABF666B12A7A/WeChat.app/WeChat]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
  </entry>
</search>
