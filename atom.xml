<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dyoung`s note</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-04T09:01:47.572Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>dyoung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过Runtime源码，分析OC消息发送及处理</title>
    <link href="http://yoursite.com/2019/03/04/runtime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/"/>
    <id>http://yoursite.com/2019/03/04/runtime消息发送/</id>
    <published>2019-03-04T08:53:59.000Z</published>
    <updated>2019-05-04T09:01:47.572Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;#前言&lt;/p&gt;
&lt;p&gt;日常开发中我们得知，当我们通过对象调用一个方法时，本质是通过&lt;code&gt;objc_msgSend&lt;/code&gt;给对象发送消息。这点我们可以通过&lt;code&gt;clang&lt;/code&gt;编译后的代码得知。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MyPerson *p = [MyPerson new];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc OC源文件  -o  输出的CPP文件&lt;/code&gt;编译得：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS正向" scheme="http://yoursite.com/categories/iOS%E6%AD%A3%E5%90%91/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>通过dyld源码，详细分析应用加载</title>
    <link href="http://yoursite.com/2019/01/14/dyld%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/01/14/dyld应用加载/</id>
    <published>2019-01-14T07:11:00.000Z</published>
    <updated>2019-05-04T09:01:13.842Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在我们初学iOS的时候，分析一个程序的执行流程都是从main函数开始的。但是在main函数之前其实也做了不少操作，值得我们分析一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们知道一个类的&lt;code&gt;load&lt;/code&gt;的方法是先于&lt;code&gt;main&lt;/code&gt;函数执行的，通过对&lt;code&gt;load&lt;/code&gt;方法设置一个断点，查看调用栈可知程序在加载过程中大致所执行的一些方法。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS正向" scheme="http://yoursite.com/categories/iOS%E6%AD%A3%E5%90%91/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>iOS应用脱壳(解密)的几种方式</title>
    <link href="http://yoursite.com/2018/12/27/iOS%E5%BA%94%E7%94%A8%E8%84%B1%E5%A3%B3/"/>
    <id>http://yoursite.com/2018/12/27/iOS应用脱壳/</id>
    <published>2018-12-27T08:38:23.000Z</published>
    <updated>2019-05-04T08:58:06.656Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们日常开发提交给Appstore发布的App，都经过官方保护而加密，这样可以保证机器上跑的应用是苹果审核过的，也可以管理软件授权。经过App Store加密的应用，我们无法通过Hopper等反编译静态分析，也无法Class-Dump，在逆向分析过程中需要对加密的二进制文件进行解密才可以进行静态分析，这一过程就是大家熟知的砸壳（脱壳）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS逆向" scheme="http://yoursite.com/categories/iOS%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
</feed>
