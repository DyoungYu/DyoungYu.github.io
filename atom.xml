<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dyoung`s note</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-06T14:19:06.107Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>dyoung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法 - 二叉树</title>
    <link href="http://yoursite.com/2019/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/04/11/数据结构与算法-二叉树/</id>
    <published>2019-04-11T14:14:19.000Z</published>
    <updated>2019-05-06T14:19:06.107Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在计算机科学中，&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉树&lt;/a&gt;(Binary Tree)是包含n个节点的有限集合，该集合或者为空集（此时，二叉树称为空树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>通过Runtime源码，分析OC消息发送及处理</title>
    <link href="http://yoursite.com/2019/03/04/runtime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/"/>
    <id>http://yoursite.com/2019/03/04/runtime消息发送/</id>
    <published>2019-03-04T08:53:59.000Z</published>
    <updated>2019-05-04T09:08:46.716Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;#前言&lt;/p&gt;
&lt;p&gt;日常开发中我们得知，当我们通过对象调用一个方法时，本质是通过&lt;code&gt;objc_msgSend&lt;/code&gt;给对象发送消息。这点我们可以通过&lt;code&gt;clang&lt;/code&gt;编译后的代码得知。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MyPerson *p = [MyPerson new];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS正向" scheme="http://yoursite.com/categories/iOS%E6%AD%A3%E5%90%91/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>通过dyld源码，详细分析应用加载</title>
    <link href="http://yoursite.com/2019/01/14/dyld%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/01/14/dyld应用加载/</id>
    <published>2019-01-14T07:11:00.000Z</published>
    <updated>2019-05-04T09:01:13.842Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在我们初学iOS的时候，分析一个程序的执行流程都是从main函数开始的。但是在main函数之前其实也做了不少操作，值得我们分析一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们知道一个类的&lt;code&gt;load&lt;/code&gt;的方法是先于&lt;code&gt;main&lt;/code&gt;函数执行的，通过对&lt;code&gt;load&lt;/code&gt;方法设置一个断点，查看调用栈可知程序在加载过程中大致所执行的一些方法。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS正向" scheme="http://yoursite.com/categories/iOS%E6%AD%A3%E5%90%91/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>iOS应用脱壳(解密)的几种方式</title>
    <link href="http://yoursite.com/2018/12/27/iOS%E5%BA%94%E7%94%A8%E8%84%B1%E5%A3%B3/"/>
    <id>http://yoursite.com/2018/12/27/iOS应用脱壳/</id>
    <published>2018-12-27T08:38:23.000Z</published>
    <updated>2019-05-04T08:58:06.656Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们日常开发提交给Appstore发布的App，都经过官方保护而加密，这样可以保证机器上跑的应用是苹果审核过的，也可以管理软件授权。经过App Store加密的应用，我们无法通过Hopper等反编译静态分析，也无法Class-Dump，在逆向分析过程中需要对加密的二进制文件进行解密才可以进行静态分析，这一过程就是大家熟知的砸壳（脱壳）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS逆向" scheme="http://yoursite.com/categories/iOS%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA原理探究及命令行实践</title>
    <link href="http://yoursite.com/2018/10/04/rsa%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/10/04/rsa原理探究/</id>
    <published>2018-10-04T09:06:01.000Z</published>
    <updated>2019-05-04T09:10:33.228Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;RSA算法是非对称加密算法,在1977年被&lt;a href=&quot;https://baike.baidu.com/item/%E7%BD%97%E7%BA%B3%E5%BE%B7%C2%B7%E6%9D%8E%E7%BB%B4%E6%96%AF%E7%89%B9/700199&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;罗纳德·李维斯特&lt;/a&gt;（Ron Rivest）、&lt;a href=&quot;https://baike.baidu.com/item/%E9%98%BF%E8%BF%AA%C2%B7%E8%90%A8%E8%8E%AB%E5%B0%94&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿迪·萨莫尔&lt;/a&gt;（Adi Shamir）和&lt;a href=&quot;https://baike.baidu.com/item/%E4%BC%A6%E7%BA%B3%E5%BE%B7%C2%B7%E9%98%BF%E5%BE%B7%E6%9B%BC/12575612&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;伦纳德·阿德曼&lt;/a&gt;（Leonard Adleman）一起提出的,故取名为RSA非对称加密算法,而今在计算机数据加密领域以及电子商业中广泛使用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS正向" scheme="http://yoursite.com/categories/iOS%E6%AD%A3%E5%90%91/"/>
    
    
  </entry>
  
</feed>
