<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dyoung`s note</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-06T14:39:01.367Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>dyoung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法 - 二叉树</title>
    <link href="http://yoursite.com/2019/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/04/11/数据结构与算法-二叉树/</id>
    <published>2019-04-11T14:14:19.000Z</published>
    <updated>2019-05-06T14:39:01.367Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在计算机科学中，&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉树&lt;/a&gt;(Binary Tree)是包含n个节点的有限集合，该集合或者为空集（此时，二叉树称为空树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>通过Runtime源码，分析OC消息发送及处理</title>
    <link href="http://yoursite.com/2019/03/04/runtime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/"/>
    <id>http://yoursite.com/2019/03/04/runtime消息发送/</id>
    <published>2019-03-04T08:53:59.000Z</published>
    <updated>2019-05-06T14:51:08.325Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;日常开发中我们得知，当我们通过对象调用一个方法时，本质是通过&lt;code&gt;objc_msgSend&lt;/code&gt;给对象发送消息。这点我们可以通过&lt;code&gt;clang&lt;/code&gt;编译后的代码得知。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MyPerson *p = [MyPerson new];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS正向" scheme="http://yoursite.com/categories/iOS%E6%AD%A3%E5%90%91/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>通过dyld源码，详细分析应用加载</title>
    <link href="http://yoursite.com/2019/01/14/dyld%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/01/14/dyld应用加载/</id>
    <published>2019-01-14T07:11:00.000Z</published>
    <updated>2019-05-06T14:49:53.914Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在我们初学iOS的时候，分析一个程序的执行流程都是从main函数开始的。但是在main函数之前其实也做了不少操作，值得我们分析一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们知道一个类的&lt;code&gt;load&lt;/code&gt;的方法是先于&lt;code&gt;main&lt;/code&gt;函数执行的，通过对&lt;code&gt;load&lt;/code&gt;方法设置一个断点，查看调用栈可知程序在加载过程中大致所执行的一些方法。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS正向" scheme="http://yoursite.com/categories/iOS%E6%AD%A3%E5%90%91/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>iOS应用脱壳(解密)的几种方式</title>
    <link href="http://yoursite.com/2018/12/27/iOS%E5%BA%94%E7%94%A8%E8%84%B1%E5%A3%B3/"/>
    <id>http://yoursite.com/2018/12/27/iOS应用脱壳/</id>
    <published>2018-12-27T08:38:23.000Z</published>
    <updated>2019-05-06T14:48:22.782Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们日常开发提交给Appstore发布的App，都经过官方保护而加密，这样可以保证机器上跑的应用是苹果审核过的，也可以管理软件授权。经过App Store加密的应用，我们无法通过Hopper等反编译静态分析，也无法Class-Dump，在逆向分析过程中需要对加密的二进制文件进行解密才可以进行静态分析，这一过程就是大家熟知的砸壳（脱壳）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS逆向" scheme="http://yoursite.com/categories/iOS%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA原理探究及命令行实践</title>
    <link href="http://yoursite.com/2018/10/04/rsa%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/10/04/rsa原理探究/</id>
    <published>2018-10-04T09:06:01.000Z</published>
    <updated>2019-05-06T14:53:31.206Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;RSA算法是非对称加密算法,在1977年被&lt;a href=&quot;https://baike.baidu.com/item/%E7%BD%97%E7%BA%B3%E5%BE%B7%C2%B7%E6%9D%8E%E7%BB%B4%E6%96%AF%E7%89%B9/700199&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;罗纳德·李维斯特&lt;/a&gt;（Ron Rivest）、&lt;a href=&quot;https://baike.baidu.com/item/%E9%98%BF%E8%BF%AA%C2%B7%E8%90%A8%E8%8E%AB%E5%B0%94&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿迪·萨莫尔&lt;/a&gt;（Adi Shamir）和&lt;a href=&quot;https://baike.baidu.com/item/%E4%BC%A6%E7%BA%B3%E5%BE%B7%C2%B7%E9%98%BF%E5%BE%B7%E6%9B%BC/12575612&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;伦纳德·阿德曼&lt;/a&gt;（Leonard Adleman）一起提出的,故取名为RSA非对称加密算法,而今在计算机数据加密领域以及电子商业中广泛使用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS正向" scheme="http://yoursite.com/categories/iOS%E6%AD%A3%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS多线程 - GCD源码分析</title>
    <link href="http://yoursite.com/2018/09/13/GCD-%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2018/09/13/GCD-源码/</id>
    <published>2018-09-13T14:42:55.000Z</published>
    <updated>2019-05-13T14:52:44.356Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前已经尝试对GCD的各个API进行了简单的实践总结，并记录为&lt;a href=&quot;https://yudongyang.win/2018/08/07/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD%E5%9F%BA%E7%A1%80%E5%AE%9E%E8%B7%B5/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博客&lt;/a&gt;,为深入研究，决定硬着头皮读一读&lt;a href=&quot;https://github.com/DyoungYu/SourceCode/tree/master/libdispatch-1008.220.2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GCD的源码-libdispatch-1008.220.2&lt;/a&gt;。&lt;br&gt;源码很难，嵌套很深，本文只是针对GCD常见API的底层实现作简单总结笔记，记录自己的一些理解。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS正向" scheme="http://yoursite.com/categories/iOS%E6%AD%A3%E5%90%91/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程 - GCD基础实践</title>
    <link href="http://yoursite.com/2018/08/07/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD%E5%9F%BA%E7%A1%80%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/08/07/iOS多线程-GCD基础实践/</id>
    <published>2018-08-07T13:56:11.000Z</published>
    <updated>2019-05-08T15:00:29.177Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。下面介绍GCD的基础使用.&lt;/p&gt;
    
    </summary>
    
      <category term="iOS正向" scheme="http://yoursite.com/categories/iOS%E6%AD%A3%E5%90%91/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CALayer 属性及方法介绍</title>
    <link href="http://yoursite.com/2017/06/02/CALayer%E6%96%B9%E6%B3%95%E5%8F%8A%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2017/06/02/CALayer方法及属性介绍/</id>
    <published>2017-06-02T15:02:30.000Z</published>
    <updated>2019-05-08T15:10:10.737Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;如下图：&lt;code&gt;UIView&lt;/code&gt;可以处理触摸事件，但&lt;code&gt;CALayer&lt;/code&gt;是不支持交互的（不清楚具体的响应链的）。实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，&lt;code&gt;UIView&lt;/code&gt;仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Core Animation" scheme="http://yoursite.com/tags/Core-Animation/"/>
    
  </entry>
  
  <entry>
    <title>UIBezierPath - 基础API介绍实践</title>
    <link href="http://yoursite.com/2017/05/14/UIBezierPath-%E5%85%A8%E9%9D%A2%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2017/05/14/UIBezierPath-全面介绍/</id>
    <published>2017-05-14T14:36:12.000Z</published>
    <updated>2019-05-08T14:54:17.313Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;UIKit中的UIBezierPath是Core Graphics框架关于path的一个封装。可以创建基于矢量的路径，例如椭圆或者矩形，或者有多个直线和曲线段组成的形状.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/1da89c42401b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Core Graphics 的基本介绍与使用&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Core Graphics" scheme="http://yoursite.com/tags/Core-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Core Graphics - 基础介绍</title>
    <link href="http://yoursite.com/2017/05/08/CoreGraphics-%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2017/05/08/CoreGraphics-基础介绍/</id>
    <published>2017-05-08T14:52:31.000Z</published>
    <updated>2019-05-08T15:05:21.327Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;CoreGraphics也称为Quartz 2D 是UIKit下的主要绘图系统，频繁的用于绘制自定义视图。Core Graphics是高度集成于UIView和其他UIKit部分的。Core Graphics数据结构和函数可以通过前缀CG来识别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1787548-77e69acfc910a49e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Core Graphics" scheme="http://yoursite.com/tags/Core-Graphics/"/>
    
  </entry>
  
</feed>
